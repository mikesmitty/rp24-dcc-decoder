
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>shared: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/mikesmitty/rp24-dcc-decoder/internal/shared/shared_mock.go (0.0%)</option>
				
				<option value="file1">github.com/mikesmitty/rp24-dcc-decoder/main.go (0.0%)</option>
				
				<option value="file2">github.com/mikesmitty/rp24-dcc-decoder/pkg/cv/cv.go (0.0%)</option>
				
				<option value="file3">github.com/mikesmitty/rp24-dcc-decoder/pkg/cv/cv_defaults.go (0.0%)</option>
				
				<option value="file4">github.com/mikesmitty/rp24-dcc-decoder/pkg/cv/cv_mock.go (0.0%)</option>
				
				<option value="file5">github.com/mikesmitty/rp24-dcc-decoder/pkg/dcc/dcc.go (2.5%)</option>
				
				<option value="file6">github.com/mikesmitty/rp24-dcc-decoder/pkg/dcc/dcc_mock.go (0.0%)</option>
				
				<option value="file7">github.com/mikesmitty/rp24-dcc-decoder/pkg/dcc/functions.go (17.9%)</option>
				
				<option value="file8">github.com/mikesmitty/rp24-dcc-decoder/pkg/dcc/message.go (76.6%)</option>
				
				<option value="file9">github.com/mikesmitty/rp24-dcc-decoder/pkg/dcc/message_advancedextended.go (0.0%)</option>
				
				<option value="file10">github.com/mikesmitty/rp24-dcc-decoder/pkg/dcc/message_extended.go (94.7%)</option>
				
				<option value="file11">github.com/mikesmitty/rp24-dcc-decoder/pkg/dcc/message_servicemode.go (79.3%)</option>
				
				<option value="file12">github.com/mikesmitty/rp24-dcc-decoder/pkg/dcc/message_xpom.go (33.3%)</option>
				
				<option value="file13">github.com/mikesmitty/rp24-dcc-decoder/pkg/dcc/monitor.go (0.0%)</option>
				
				<option value="file14">github.com/mikesmitty/rp24-dcc-decoder/pkg/deleteme-motor/direction.go (0.0%)</option>
				
				<option value="file15">github.com/mikesmitty/rp24-dcc-decoder/pkg/deleteme-motor/motor_mock.go (0.0%)</option>
				
				<option value="file16">github.com/mikesmitty/rp24-dcc-decoder/pkg/hal/hal.go (0.0%)</option>
				
				<option value="file17">github.com/mikesmitty/rp24-dcc-decoder/pkg/hal/hal_mock.go (0.0%)</option>
				
				<option value="file18">github.com/mikesmitty/rp24-dcc-decoder/pkg/hal/i2s.go (0.0%)</option>
				
				<option value="file19">github.com/mikesmitty/rp24-dcc-decoder/pkg/hal/outputs.go (0.0%)</option>
				
				<option value="file20">github.com/mikesmitty/rp24-dcc-decoder/pkg/hal/pwm_mock.go (0.0%)</option>
				
				<option value="file21">github.com/mikesmitty/rp24-dcc-decoder/pkg/iir/iir.go (0.0%)</option>
				
				<option value="file22">github.com/mikesmitty/rp24-dcc-decoder/pkg/motor/backemf.go (0.0%)</option>
				
				<option value="file23">github.com/mikesmitty/rp24-dcc-decoder/pkg/motor/config.go (20.8%)</option>
				
				<option value="file24">github.com/mikesmitty/rp24-dcc-decoder/pkg/motor/const.go (0.0%)</option>
				
				<option value="file25">github.com/mikesmitty/rp24-dcc-decoder/pkg/motor/motor.go (0.0%)</option>
				
				<option value="file26">github.com/mikesmitty/rp24-dcc-decoder/pkg/motor/pwm.go (0.0%)</option>
				
				<option value="file27">github.com/mikesmitty/rp24-dcc-decoder/pkg/ringbuffer/ringbuffer_mock.go (0.0%)</option>
				
				<option value="file28">github.com/mikesmitty/rp24-dcc-decoder/pkg/store/flash_mock.go (63.6%)</option>
				
				<option value="file29">github.com/mikesmitty/rp24-dcc-decoder/pkg/store/store.go (62.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">//go:build !rp

package shared

// Avoid requiring packages that require specific hardware so we can run unit tests

const (
        KHz = 1_000
        MHz = 1_000_000

        NoPin = MockPin(0xff)
)

// package rp2-pio
type I2S interface {
        SetSampleFrequency(f uint32) error
        WriteMono(data []uint16) (int, error)
}

// package machine
type Pin interface {
        Configure(MockPinConfig)
        Get() bool
        High()
        Low()
        Set(bool)
        SetInterrupt(MockPinChange, func(Pin)) error
}

// package machine
type PinConfig any

// package machine
type PWMConfig any

// package rp2-pio
type StateMachine interface {
        IsRxFIFOEmpty() bool
        IsRxFIFOFull() bool
        RxFIFOLevel() uint32
        RxGet() uint32
        SetEnabled(bool)
}

type CVCallbackFunc func(uint16, uint8) bool

type OutputCallback func(uint16, bool)

type MockPin uint8

func (m MockPin) Configure(mode MockPinConfig) {<span class="cov0" title="0">}</span>

func (m MockPin) Get() bool <span class="cov0" title="0">{
        return false
}</span>

func (m MockPin) High() {<span class="cov0" title="0">}</span>

func (m MockPin) Low() {<span class="cov0" title="0">}</span>

func (m MockPin) Set(bool) {<span class="cov0" title="0">}</span>

func (m MockPin) SetInterrupt(MockPinChange, func(Pin)) error <span class="cov0" title="0">{
        return nil
}</span>

type MockPinChange uint8

type MockPinConfig struct {
        Mode MockPinMode
}

type MockPinMode uint8
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "strconv"
        "strings"
        "time"

        "github.com/mikesmitty/rp24-dcc-decoder/internal/shared"
        "github.com/mikesmitty/rp24-dcc-decoder/pkg/cv"
        "github.com/mikesmitty/rp24-dcc-decoder/pkg/dcc"
        "github.com/mikesmitty/rp24-dcc-decoder/pkg/hal"
        "github.com/mikesmitty/rp24-dcc-decoder/pkg/motor"
)

var hw *hal.HAL

var version = "1.1.1"

func main() <span class="cov0" title="0">{
        time.Sleep(3 * time.Second) // FIXME: Cleanup

        hw = hal.NewHAL()
        cvHandler := cv.NewCVHandler(versionToBytes(version))

        dccPin, ok := hw.PinOk("dcc")
        if !ok </span><span class="cov0" title="0">{
                panic("DCC pin not found")</span>
        }

        <span class="cov0" title="0">motorA, okA := hw.PinOk("motorA")
        motorB, okB := hw.PinOk("motorB")
        emfA, okEA := hw.PinOk("emfA")
        emfB, okEB := hw.PinOk("emfB")
        adcRef, okADC := hw.PinOk("adcRef")
        if !okA || !okB || !okEA || !okEB || !okADC </span><span class="cov0" title="0">{
                panic("Motor pins not found")</span>
        }

        <span class="cov0" title="0">m := motor.NewMotor(cvHandler, hw, motorA, motorB, emfA, emfB, adcRef)

        outputPins := make([]shared.Pin, 0, len(outputs))
        for _, output := range outputs </span><span class="cov0" title="0">{
                if pin, ok := hw.PinOk(output); ok </span><span class="cov0" title="0">{
                        outputPins = append(outputPins, pin)
                }</span>
        }

        <span class="cov0" title="0">println("Starting DCC")
        capPin := hw.Pin("capCharge")
        rcTxPin := hw.Pin("railcom")
        pioNum := 0
        d, err := dcc.NewDecoder(cvHandler, m, pioNum, dccPin, capPin, rcTxPin, outputPins)
        if err != nil </span><span class="cov0" title="0">{
                panic(err.Error())</span>
        }

        // Register available outputs
        <span class="cov0" title="0">for _, output := range outputs </span><span class="cov0" title="0">{
                if _, ok := hw.PinOk(output); ok </span><span class="cov0" title="0">{
                        d.RegisterOutput(output, hw.GetOutputCallback(output))
                }</span>
        }

        <span class="cov0" title="0">cvHandler.IndexPage()
        // d.SetAddress(3)    // FIXME: Cleanup
        d.SetAddress(2350)                // FIXME: Cleanup
        cvHandler.SetSync(29, 0b00100010) // FIXME: Cleanup
        go m.Run()
        go m.RunEMF()
        d.Monitor()</span>
}

func versionToBytes(version string) []uint8 <span class="cov0" title="0">{
        versionParts := strings.Split(version, ".")
        if len(versionParts) != 3 </span><span class="cov0" title="0">{
                panic("invalid version string length")</span>
        }
        <span class="cov0" title="0">var versionBytes []uint8
        for _, part := range versionParts </span><span class="cov0" title="0">{
                partInt, err := strconv.Atoi(part)
                if err != nil </span><span class="cov0" title="0">{
                        panic("invalid version string")</span>
                }
                <span class="cov0" title="0">versionBytes = append(versionBytes, uint8(partInt))</span>
        }
        <span class="cov0" title="0">return versionBytes</span>
}

var outputs = []string{
        "lampFront",
        "lampRear",
        "aux1",
        "aux2",
        "aux3",
        "aux4",
        "aux5",
        "aux6",
        "aux7",
        "aux8",
        "aux10",
        "aux11",
        "aux12",
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package cv

import (
        "github.com/mikesmitty/rp24-dcc-decoder/internal/shared"
        "github.com/mikesmitty/rp24-dcc-decoder/pkg/store"
)

type Handler interface {
        CV(uint16) uint8
        CVOk(uint16) (uint8, bool)
        IndexedCV(uint16, uint16) uint8
        IndexedCVOk(uint16, uint16) (uint8, bool)
        Set(uint16, uint8) bool
        SetSync(uint16, uint8) bool
        IndexedSet(uint16, uint16, uint8) bool
        IndexedSetSync(uint16, uint16, uint8) bool
        Reset(uint16) bool
        ResetAll()
        ProcessChanges()
        RegisterCallback(uint16, shared.CVCallbackFunc)
        IndexPage(...uint8) uint16
        LoadIndex(uint8, uint8) error
}

var _ Handler = (*CVHandler)(nil)

type CVHandler struct {
        cvStore     *store.Store
        cvCallbacks map[uint16][]func(uint16, uint8) bool
}

var fwVersion []uint8

func NewCVHandler(version []uint8) *CVHandler <span class="cov0" title="0">{
        s := store.NewStore()
        c := &amp;CVHandler{
                cvCallbacks: make(map[uint16][]func(uint16, uint8) bool),
                cvStore:     s,
        }

        if len(version) != 3 </span><span class="cov0" title="0">{
                panic("invalid version length")</span>
        }
        <span class="cov0" title="0">fwVersion = version

        /* TODO: Check if the version has changed
        lastVersion, _ := s.IndexedCV(0, 7)
        if lastVersion != version {
                // TODO: Do stuff if the version has changed
        }
        */

        // TODO: Handle CVs &gt; 256 properly. Treating CVs as if the index is separate
        // makes handling callback functions a big problem. Also, defaults get kinda
        // wonky. Need to refactor for that change if/when CVs &gt; 256 are implemented

        // Load the last-used index from flash
        cv31, _ := s.IndexedCV(0, 31)
        cv32, _ := s.IndexedCV(0, 32)
        err := c.LoadIndex(cv31, cv32)
        if err != nil </span><span class="cov0" title="0">{
                println("could not load index: " + err.Error())
        }</span>

        <span class="cov0" title="0">return c</span>
}

func (c *CVHandler) RegisterCallback(cvNumber uint16, fn shared.CVCallbackFunc) <span class="cov0" title="0">{
        if _, ok := c.CVOk(cvNumber); !ok </span><span class="cov0" title="0">{
                // It's not likely this will ever happen, but just to be sure
                println("CV not found: ", cvNumber)
                panic("CV not found")</span>
        }
        <span class="cov0" title="0">c.cvCallbacks[cvNumber] = append(c.cvCallbacks[cvNumber], fn)
        // Initialize the callback with the current value
        fn(cvNumber, c.CV(cvNumber))</span>
}

// Return the current index page indicated by CV31/32 or a provided equivalent
func (c *CVHandler) IndexPage(indexCVs ...uint8) uint16 <span class="cov0" title="0">{
        // TODO: Set limits around max index pages when indexes are implemented

        var cv31, cv32 uint8
        if len(indexCVs) &lt; 2 </span><span class="cov0" title="0">{
                cv31, _ = c.cvStore.IndexedCV(0, 31)
                cv32, _ = c.cvStore.IndexedCV(0, 32)
        }</span> else<span class="cov0" title="0"> {
                cv31 = indexCVs[0]
                cv32 = indexCVs[1]
        }</span>
        // 00010000
        <span class="cov0" title="0">if cv31 &lt; 16 </span><span class="cov0" title="0">{
                return 0
        }</span>
        // 00000000 00000000 is page 0
        // 00010000 00000000 is page 1 (257-512)
        <span class="cov0" title="0">return (uint16(cv31-16)&lt;&lt;8 | uint16(cv32)) + 1</span>
}

func (c *CVHandler) CV(cvNumber uint16) uint8 <span class="cov0" title="0">{
        return c.IndexedCV(c.IndexPage(), cvNumber)
}</span>

func (c *CVHandler) CVOk(cvNumber uint16) (uint8, bool) <span class="cov0" title="0">{
        return c.IndexedCVOk(c.IndexPage(), cvNumber)
}</span>

// IndexedCV returns the value of a CV given an index page and CV number
func (c *CVHandler) IndexedCV(index, cvNumber uint16) uint8 <span class="cov0" title="0">{
        v, _ := c.IndexedCVOk(index, cvNumber)
        return v
}</span>

// IndexedCVOk returns the value and pre-existence of a CV given an index page and CV number
func (c *CVHandler) IndexedCVOk(index, cvNumber uint16) (uint8, bool) <span class="cov0" title="0">{
        // Keep CV31/32 reads/writes constrained to index 0
        if cvNumber == 31 || cvNumber == 32 </span><span class="cov0" title="0">{
                index = 0
        }</span>
        <span class="cov0" title="0">return c.cvStore.IndexedCV(index, cvNumber)</span>
        // v, ok := c.cvStore.IndexedCV(index, cvNumber)    // FIXME: Cleanup
        // fmt.Printf("CV %d: %08b %d\r\n", cvNumber, v, v) // FIXME: Cleanup
        // return v, ok                                     // FIXME: Cleanup
}

// Set sets a CV value and allows it to be written to flash in batches
func (c *CVHandler) Set(cvNumber uint16, value uint8) bool <span class="cov0" title="0">{
        if cvNumber == 31 || cvNumber == 32 </span><span class="cov0" title="0">{
                // Don't allow setting of CV31/32 directly, only allow through Config Variable Access commands
                return false
        }</span>
        <span class="cov0" title="0">return c.cvStore.Set(cvNumber, value)</span>
}

// SetSync sets a CV and does not return until it is persisted to flash
func (c *CVHandler) SetSync(cvNumber uint16, value uint8) bool <span class="cov0" title="0">{
        ok := c.Set(cvNumber, value)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return c.cvStore.Persist(cvNumber, value)</span>
}

// IndexedSet sets a CV value given a paging index and allows it to be written to flash in batches
func (c *CVHandler) IndexedSet(index, cvNumber uint16, value uint8) bool <span class="cov0" title="0">{
        // Ignore indexes beyond those we support
        if index &gt; maxCVIndexPage </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check if the CV exists. Unset CVs are not allowed to be set
        // TODO: Need some way of checking if a CV in another index is valid before using higher level CVs
        <span class="cov0" title="0">prev, ok := c.IndexedCVOk(index, cvNumber)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">rejected := false

        // Run the callbacks first to make sure the value isn't rejected
        if callbacks, ok := c.cvCallbacks[cvNumber]; ok </span><span class="cov0" title="0">{
                for _, fn := range callbacks </span><span class="cov0" title="0">{
                        if !fn(cvNumber, value) </span><span class="cov0" title="0">{
                                rejected = true
                        }</span>
                }
                <span class="cov0" title="0">if rejected </span><span class="cov0" title="0">{
                        // Run it back now ya'll
                        // Prod the callbacks to roll back their caches
                        for _, fn := range callbacks </span><span class="cov0" title="0">{
                                fn(cvNumber, prev)
                        }</span>
                        <span class="cov0" title="0">return false</span>
                }
        }
        <span class="cov0" title="0">return c.IndexedSet(index, cvNumber, value)</span>
}

// IndexedSetSync sets a CV given a paging index and does not return until it is persisted to flash
func (c *CVHandler) IndexedSetSync(index, cvNumber uint16, value uint8) bool <span class="cov0" title="0">{
        if !c.IndexedSet(index, cvNumber, value) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">return c.cvStore.IndexedPersist(index, cvNumber, value)</span>
}

func (c *CVHandler) Reset(cvNumber uint16) bool <span class="cov0" title="0">{
        if cvNumber == 31 || cvNumber == 32 </span><span class="cov0" title="0">{
                // Don't allow resetting of CV31/32 directly, only allow through Config Variable Access commands
                return true
        }</span>
        <span class="cov0" title="0">return c.cvStore.Reset(cvNumber)</span>
}

func (c *CVHandler) ResetAll() <span class="cov0" title="0">{
        c.cvStore.ResetAll()
}</span>

func (c *CVHandler) ProcessChanges() <span class="cov0" title="0">{
        c.cvStore.ProcessChanges()
}</span>

func (c *CVHandler) Run() <span class="cov0" title="0">{
        c.cvStore.Run()
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package cv

import (
        "errors"

        "github.com/mikesmitty/rp24-dcc-decoder/pkg/store"
)

// Save the current version to flash in case we decide to change the storage format or update logic
const roPersist = store.Persistent | store.ReadOnly

const maxCVIndexPage = 0

func (c *CVHandler) LoadIndex(cv31, cv32 uint8) error <span class="cov0" title="0">{
        index := c.IndexPage(cv31, cv32)
        if index &gt; maxCVIndexPage </span><span class="cov0" title="0">{
                return errors.New("invalid index page")
        }</span>

        <span class="cov0" title="0">println("Loading CV index page", index)

        // Persist any remaining dirty flags
        if ok := c.cvStore.ProcessChanges(); !ok </span><span class="cov0" title="0">{
                // Going to not consider this a critical error at least for now
                println("could not save changes to flash")
        }</span>

        // Clear out the existing CVs and load the new defaults
        <span class="cov0" title="0">c.cvStore.Clear()
        switch index </span>{
        // case 0
        default:<span class="cov0" title="0">
                // Number, Default, Flags
                c.cvStore.SetDefault(1, 3, store.Persistent)     // ADDR: Primary address
                c.cvStore.SetDefault(2, 10, store.Persistent)    // MOTOR: Vstart (minimum throttle required to start moving)
                c.cvStore.SetDefault(3, 0, store.Persistent)     // MOTOR: Default acceleration rate (0 = immediate)
                c.cvStore.SetDefault(4, 0, store.Persistent)     // MOTOR: Default deceleration rate (0 = immediate)
                c.cvStore.SetDefault(5, 255, store.Persistent)   // MOTOR: Vmax - maximum voltage
                c.cvStore.SetDefault(6, 128, store.Persistent)   // MOTOR: Vmid - mid-range voltage
                c.cvStore.SetDefault(7, fwVersion[0], roPersist) // SYS: Major version number
                c.cvStore.SetDefault(8, 0x0D, store.ReadOnly)    // SYS: Manufacturer ID: "Public Domain &amp; DIY Decoders"
                c.cvStore.SetDefault(9, 40, store.Persistent)    // MOTOR: PWM frequency in kHz (1-250)
                c.cvStore.SetDefault(10, 0, store.Persistent)    // MOTOR: Back EMF motor control cutoff speed
                c.cvStore.SetDefault(11, 10, store.Persistent)   // SYS: Control packet keepalive timeout in 100ms units

                // Extended address - Top 2 bits of MSB must be 1 and are ignored (min 192, max 231), allowing for any 4 digit number
                c.cvStore.SetDefault(17, 0, store.Persistent) // ADDR: MSB
                c.cvStore.SetDefault(18, 0, store.Persistent) // ADDR: LSB
                c.cvStore.SetDefault(19, 0, store.Persistent) // CONSIST: ADDR: Consist address
                c.cvStore.SetDefault(20, 0, store.Persistent) // CONSIST: ADDR: Consist extended address
                c.cvStore.SetDefault(21, 0, store.Persistent) // CONSIST: Consist address function activation F1-F8
                c.cvStore.SetDefault(22, 0, store.Persistent) // CONSIST: Consist address function activation F0f, F0r, F9-F12
                c.cvStore.SetDefault(23, 0, store.Persistent) // MOTOR: No acceleration adjustment
                c.cvStore.SetDefault(24, 0, store.Persistent) // MOTOR: No deceleration adjustment

                // CV 28:
                // Used to configure decoder’s Bi-Directional communication characteristics when CV29-Bit 3 is set
                // Bit 0 = Enable/Disable Unsolicited Decoder Initiated Transmission
                // Bit 1 = Enable/Disable Initiated Broadcast Transmission using Asymmetrical DCC Signal
                // Bit 2 = Enable/Disable Initiated Broadcast Transmission using Signal Controlled Influence Signal
                c.cvStore.SetDefault(28, 0, store.Persistent) // BiDi: Off

                // CV 29:
                // Bit 7: 0 = Mobile decoder, 1 = Accessory decoder
                // Bit 6: Reserved
                // Bit 5: 0 = Short address mode, 1 = Extended address mode
                // Bit 4: 0 = CV 2,5,6 speed curve, 1 = CV 25 speed table
                // Bit 3: 1 = RailCom enabled
                // Bit 2: 0 = DCC only, 1 = DCC &amp; DC
                // Bit 1: 0 = 14 speed steps, 1 = 28/128 speed steps
                // Bit 0: 0 = Forward direction, 1 = Reverse direction
                c.cvStore.SetDefault(29, 0b00000010, store.Persistent) // BiDi disabled, 28/128 speed steps TODO: Enable BiDi

                c.cvStore.SetDefault(30, 0, store.Volatile) // ERROR: Error code TODO: Implement error codes
                c.cvStore.SetDefault(31, 0, store.Volatile) // INDEX: CV index paging MSB (0 is disabled, 1-15 are reserved)
                c.cvStore.SetDefault(32, 0, store.Volatile) // INDEX: CV index paging LSB

                // TODO: Reimplement for more flexibility
                c.cvStore.SetDefault(33, 0b00000001, store.Persistent) // FUNCTIONS: Output mapping for F0f
                c.cvStore.SetDefault(34, 0b00000010, store.Persistent) // FUNCTIONS: Output mapping for F0r
                c.cvStore.SetDefault(35, 0b00000100, store.Persistent) // FUNCTIONS: Output mapping for F1
                c.cvStore.SetDefault(36, 0b00001000, store.Persistent) // FUNCTIONS: Output mapping for F2
                c.cvStore.SetDefault(37, 0b00010000, store.Persistent) // FUNCTIONS: Output mapping for F3
                c.cvStore.SetDefault(38, 0b00000100, store.Persistent) // FUNCTIONS: Output mapping for F4
                c.cvStore.SetDefault(39, 0b00001000, store.Persistent) // FUNCTIONS: Output mapping for F5
                c.cvStore.SetDefault(40, 0b00010000, store.Persistent) // FUNCTIONS: Output mapping for F6
                c.cvStore.SetDefault(41, 0b00100000, store.Persistent) // FUNCTIONS: Output mapping for F7
                c.cvStore.SetDefault(42, 0b01000000, store.Persistent) // FUNCTIONS: Output mapping for F8
                c.cvStore.SetDefault(43, 0b00010000, store.Persistent) // FUNCTIONS: Output mapping for F9
                c.cvStore.SetDefault(44, 0b00100000, store.Persistent) // FUNCTIONS: Output mapping for F10
                c.cvStore.SetDefault(45, 0b01000000, store.Persistent) // FUNCTIONS: Output mapping for F11
                c.cvStore.SetDefault(46, 0b10000000, store.Persistent) // FUNCTIONS: Output mapping for F12

                c.cvStore.SetDefault(51, 10, store.Persistent)  // MOTOR: Low to high PID gain cutover speed step
                c.cvStore.SetDefault(52, 10, store.Persistent)  // MOTOR: Low speed Kp gain (proportional)
                c.cvStore.SetDefault(53, 130, store.Persistent) // MOTOR: Max speed EMF voltage
                c.cvStore.SetDefault(54, 50, store.Persistent)  // MOTOR: High speed Kp gain (proportional)
                c.cvStore.SetDefault(55, 100, store.Persistent) // MOTOR: Ki gain (integral)
                c.cvStore.SetDefault(56, 255, store.Persistent) // MOTOR: Low speed PID scaling factor

                c.cvStore.SetDefault(65, 0, store.Persistent)   // MOTOR: Startup kick to overcome static friction from a stop to speed step 1
                c.cvStore.SetDefault(66, 128, store.Persistent) // MOTOR: Forward trim
                // CV67-CV94: Speed table
                c.cvStore.SetDefault(67, 0, store.Persistent)   // MOTOR: Speed 1
                c.cvStore.SetDefault(68, 0, store.Persistent)   // MOTOR: Speed 2
                c.cvStore.SetDefault(69, 0, store.Persistent)   // MOTOR: Speed 3
                c.cvStore.SetDefault(70, 0, store.Persistent)   // MOTOR: Speed 4
                c.cvStore.SetDefault(71, 0, store.Persistent)   // MOTOR: Speed 5
                c.cvStore.SetDefault(72, 0, store.Persistent)   // MOTOR: Speed 6
                c.cvStore.SetDefault(73, 0, store.Persistent)   // MOTOR: Speed 7
                c.cvStore.SetDefault(74, 0, store.Persistent)   // MOTOR: Speed 8
                c.cvStore.SetDefault(75, 0, store.Persistent)   // MOTOR: Speed 9
                c.cvStore.SetDefault(76, 0, store.Persistent)   // MOTOR: Speed 10
                c.cvStore.SetDefault(77, 0, store.Persistent)   // MOTOR: Speed 11
                c.cvStore.SetDefault(78, 0, store.Persistent)   // MOTOR: Speed 12
                c.cvStore.SetDefault(79, 0, store.Persistent)   // MOTOR: Speed 13
                c.cvStore.SetDefault(80, 0, store.Persistent)   // MOTOR: Speed 14
                c.cvStore.SetDefault(81, 0, store.Persistent)   // MOTOR: Speed 15
                c.cvStore.SetDefault(82, 0, store.Persistent)   // MOTOR: Speed 16
                c.cvStore.SetDefault(83, 0, store.Persistent)   // MOTOR: Speed 17
                c.cvStore.SetDefault(84, 0, store.Persistent)   // MOTOR: Speed 18
                c.cvStore.SetDefault(85, 0, store.Persistent)   // MOTOR: Speed 19
                c.cvStore.SetDefault(86, 0, store.Persistent)   // MOTOR: Speed 20
                c.cvStore.SetDefault(87, 0, store.Persistent)   // MOTOR: Speed 21
                c.cvStore.SetDefault(88, 0, store.Persistent)   // MOTOR: Speed 22
                c.cvStore.SetDefault(89, 0, store.Persistent)   // MOTOR: Speed 23
                c.cvStore.SetDefault(90, 0, store.Persistent)   // MOTOR: Speed 24
                c.cvStore.SetDefault(91, 0, store.Persistent)   // MOTOR: Speed 25
                c.cvStore.SetDefault(92, 0, store.Persistent)   // MOTOR: Speed 26
                c.cvStore.SetDefault(93, 0, store.Persistent)   // MOTOR: Speed 27
                c.cvStore.SetDefault(94, 0, store.Persistent)   // MOTOR: Speed 28
                c.cvStore.SetDefault(95, 128, store.Persistent) // MOTOR: Reverse trim

                c.cvStore.SetDefault(105, 0, store.Persistent) // MISC: User identification number
                c.cvStore.SetDefault(106, 0, store.Persistent) // MISC: User identification number

                c.cvStore.SetDefault(109, fwVersion[0], roPersist) // SYS: Major version number
                c.cvStore.SetDefault(110, fwVersion[1], roPersist) // SYS: Minor version number
                c.cvStore.SetDefault(111, fwVersion[2], roPersist) // SYS: Patch version number

                c.cvStore.SetDefault(116, 50, store.Persistent)  // MOTOR: Speed step 1 back EMF measurement interval in 0.1ms steps (50-200)
                c.cvStore.SetDefault(117, 150, store.Persistent) // MOTOR: Speed step max back EMF measurement interval in 0.1ms steps (50-200)
                c.cvStore.SetDefault(118, 15, store.Persistent)  // MOTOR: Speed step 1 back EMF measurement cutout duration in 0.1ms steps (10-40)
                c.cvStore.SetDefault(119, 20, store.Persistent)</span>  // MOTOR: Speed step max back EMF measurement cutout duration in 0.1ms steps (10-40)
                // case 1:
                // CVs 257-512
        }

        <span class="cov0" title="0">_, err := c.cvStore.LoadIndex(c.IndexPage(cv31, cv32))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package cv

import "github.com/mikesmitty/rp24-dcc-decoder/internal/shared"

var _ Handler = (*MockHandler)(nil)

type MockHandler struct {
        returnValue bool
        store       map[uint16]uint8
}

func NewMockHandler(returnValue bool, values map[uint16]uint8) *MockHandler <span class="cov0" title="0">{
        return &amp;MockHandler{
                returnValue: returnValue,
                store:       values,
        }
}</span>

func (m *MockHandler) SetCV(cv uint16, value uint8) bool <span class="cov0" title="0">{
        m.store[cv] = value
        return m.returnValue
}</span>

func (m *MockHandler) CV(cv uint16) uint8 <span class="cov0" title="0">{
        return m.store[cv]
}</span>

func (m *MockHandler) CVOk(cv uint16) (uint8, bool) <span class="cov0" title="0">{
        return m.store[cv], m.returnValue
}</span>

func (m *MockHandler) IndexedCV(index uint16, cv uint16) uint8 <span class="cov0" title="0">{
        return m.store[cv]
}</span>

func (m *MockHandler) IndexedCVOk(index uint16, cv uint16) (uint8, bool) <span class="cov0" title="0">{
        return m.store[cv], m.returnValue
}</span>

func (m *MockHandler) IndexedSet(index uint16, cv uint16, value uint8) bool <span class="cov0" title="0">{
        return m.returnValue
}</span>

func (m *MockHandler) IndexedSetSync(index uint16, cv uint16, value uint8) bool <span class="cov0" title="0">{
        return m.returnValue
}</span>

func (m *MockHandler) Reset(cv uint16) bool <span class="cov0" title="0">{
        return m.returnValue
}</span>

func (m *MockHandler) ResetAll() {<span class="cov0" title="0">
}</span>

func (m *MockHandler) ProcessChanges() {<span class="cov0" title="0">
}</span>

func (m *MockHandler) Set(cv uint16, value uint8) bool <span class="cov0" title="0">{
        return m.returnValue
}</span>

func (m *MockHandler) SetSync(cv uint16, value uint8) bool <span class="cov0" title="0">{
        return m.returnValue
}</span>

func (m *MockHandler) RegisterCallback(cv uint16, fn shared.CVCallbackFunc) {<span class="cov0" title="0">
}</span>

func (m *MockHandler) IndexPage(indexCVs ...uint8) uint16 <span class="cov0" title="0">{
        return 0
}</span>

func (m *MockHandler) LoadIndex(page1, page2 uint8) error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package dcc

import (
        "errors"
        "fmt"
        "time"

        "github.com/mikesmitty/rp24-dcc-decoder/internal/shared"
        "github.com/mikesmitty/rp24-dcc-decoder/pkg/cv"
        "github.com/mikesmitty/rp24-dcc-decoder/pkg/motor"
        "github.com/mikesmitty/rp24-dcc-decoder/pkg/ringbuffer"
)

//go:generate pioasm -o go dcc.pio dcc_pio.go

func NewDecoder(cvHandler cv.Handler, m *motor.Motor, pioNum int, dccPin, capPin, rcTxPin shared.Pin, outputs []shared.Pin) (*Decoder, error) <span class="cov0" title="0">{
        d := &amp;Decoder{
                address:         make([]byte, 0, 2),
                buf:             ringbuffer.NewRingBuffer[uint32](),
                capPin:          capPin,
                consistAddress:  make([]byte, 0, 2),
                cv:              cvHandler,
                motor:           m,
                outputCallbacks: make(map[uint16][]shared.OutputCallback, 12),
                outputMapsFwd:   make(map[uint16]uint16, 12),
                outputMapsRev:   make(map[uint16]uint16, 12),
                outputPins:      outputs,
                rcTxPin:         rcTxPin,
        }

        err := d.initPIO(pioNum, dccPin)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">d.RegisterCallbacks()

        return d, nil</span>
}

// Set the address of the DCC reader
func (d *Decoder) SetAddress(addr uint16) error <span class="cov0" title="0">{
        if addr &gt; 127 </span><span class="cov0" title="0">{
                fmt.Printf("Setting extended address MSB to %d\r\n", 0xC0|byte(addr&gt;&gt;8)) // FIXME: Cleanup
                if ok := d.cv.SetSync(17, 0xC0|byte(addr&gt;&gt;8)); !ok </span><span class="cov0" title="0">{
                        return errors.New("failed to set extended address MSB")
                }</span>
                <span class="cov0" title="0">fmt.Printf("Setting extended address LSB to %d\r\n", byte(addr)) // FIXME: Cleanup
                if ok := d.cv.SetSync(18, byte(addr)); !ok </span><span class="cov0" title="0">{
                        return errors.New("failed to set extended address LSB")
                }</span>
        } else<span class="cov0" title="0"> {
                if ok := d.cv.SetSync(1, byte(addr)); !ok </span><span class="cov0" title="0">{
                        return errors.New("failed to set short address")
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (d *Decoder) setAddress(addr uint16) error <span class="cov0" title="0">{
        fmt.Printf("Setting address to %d\r\n", addr) // FIXME: Cleanup
        if addr == 0 || addr &gt; 10239 </span><span class="cov0" title="0">{
                return errors.New("address out of range")
        }</span>

        <span class="cov0" title="0">d.address = d.address[:0]
        if addr &gt; 127 </span><span class="cov0" title="0">{
                d.address = append(d.address, 0xC0|byte(addr&gt;&gt;8))
                d.address = append(d.address, byte(addr))
        }</span> else<span class="cov0" title="0"> {
                d.address = append(d.address, byte(addr))
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Enable or disable the DCC reader
func (d *Decoder) Enable(enabled bool) <span class="cov0" title="0">{
        d.sm.SetEnabled(enabled)
}</span>

func (d *Decoder) OpMode() opMode <span class="cov0" title="0">{
        return d.opMode
}</span>

func (d *Decoder) SetOpMode(mode opMode) <span class="cov0" title="0">{
        if mode == ServiceMode </span><span class="cov0" title="0">{
                // If we've received a service mode reset packet re-up the 20ms timer
                d.lastSvcResetTime = time.Now()
                d.svcModeReady = true
        }</span> else<span class="cov0" title="0"> {
                d.svcModeReady = false
        }</span>
        <span class="cov0" title="0">d.opMode = mode</span>
        // TODO: Handle exiting service mode
}

func (d *Decoder) Reset() <span class="cov8" title="1">{
        d.lastSvcResetTime = time.Now()
        d.svcModeReady = true
        // TODO: Implement reset packet handling
        /* When a Digital Decoder receives a Digital Decoder Reset Packet, it shall erase all
        volatile memory (including any speed and direction data), and return to its normal
        power-up state. If the Digital Decoder is operating a locomotive at a non-zero speed
        when it receives a Digital Decoder Reset, it shall bring the locomotive to an
        immediate stop. */
}</span>

func (d *Decoder) RegisterCallbacks() <span class="cov0" title="0">{
        d.cv.RegisterCallback(1, d.CVCallback())
        for i := uint16(17); i &lt;= 22; i++ </span><span class="cov0" title="0">{
                d.cv.RegisterCallback(i, d.CVCallback())
        }</span>
        <span class="cov0" title="0">d.cv.RegisterCallback(29, d.CVCallback())
        for i := uint16(33); i &lt;= 46; i++ </span><span class="cov0" title="0">{
                d.cv.RegisterCallback(i, d.CVCallback())
        }</span>
}

func (d *Decoder) CVCallback() shared.CVCallbackFunc <span class="cov0" title="0">{
        return func(cvNumber uint16, value uint8) bool </span><span class="cov0" title="0">{
                switch cvNumber </span>{
                case 1:<span class="cov0" title="0">
                        // Set the short address
                        // Not allowing 0 because DC mode is out of scope
                        if value &lt; 1 || value &gt; 127 </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov0" title="0">d.setAddress(uint16(value))</span>

                case 17, 18:<span class="cov0" title="0">
                        // CV17 must be in the range 192-231, CV18 can be any value
                        // The top 2 bits of CV17 are ignored when parsing the address
                        if cvNumber == 17 &amp;&amp; (value &lt; 192 || value &gt; 231) </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        // Set the extended address bytes
                        <span class="cov0" title="0">if len(d.address) &lt; int(cvNumber)-16 </span><span class="cov0" title="0">{
                                d.address = append(d.address, value)
                        }</span> else<span class="cov0" title="0"> {
                                d.address[cvNumber-17] = value
                        }</span>

                case 19, 20:<span class="cov0" title="0">
                        // Set the consist address bytes
                        // TODO: Add validation around CV19 value in extended address mode when standardized
                        if len(d.address) &lt; int(cvNumber)-18 </span><span class="cov0" title="0">{
                                d.address = append(d.address, value)
                        }</span> else<span class="cov0" title="0"> {
                                d.address[cvNumber-19] = value
                        }</span>

                case 21:<span class="cov0" title="0">
                        // Convert CV21 to a bitmask for enabling the functions via consist address (F1-F8)
                        // Clear the bits for F1-F4
                        mask := d.consistFuncMask[0] &amp; 0b11110000
                        // Set the bits for F1-F4
                        mask |= value &amp; 0b00001111
                        d.consistFuncMask[0] = mask

                        // Set the bits for F5-F8
                        d.consistFuncMask[1] = value &gt;&gt; 4</span>

                case 22:<span class="cov0" title="0">
                        // Convert CV22 to a bitmask for enabling the functions via consist address (FLf, FLr, F9-F12)
                        // TODO: Implement this for FLf and FLr separately
                        // Clear the bit for FL (F0)
                        mask := d.consistFuncMask[0] &amp;^ (1 &lt;&lt; 4)
                        // Set the bit for FL (F0) (CV bit 0 -&gt; mask bit 4, FLr is CV bit 1)
                        mask |= (value &amp; 1) &lt;&lt; 4
                        d.consistFuncMask[0] = mask

                        // Set the mask bits for F9-F12 (CV bits 2-5)
                        d.consistFuncMask[2] = (value &amp; 0b00111100) &gt;&gt; 2</span>

                case 29:<span class="cov0" title="0">
                        // CV29 bit 5: 0 = short address, 1 = extended address
                        cv17 := d.cv.CV(17)
                        if (value &amp; 0b00100000) != 0 </span><span class="cov0" title="0">{
                                if cv17 &gt;= 192 &amp;&amp; cv17 &lt;= 231 </span><span class="cov0" title="0">{
                                        // If CV17 is 192 and CV18 is 0 the long address would be 0, abort
                                        if cv17 == 192 &amp;&amp; d.cv.CV(18) == 0 </span><span class="cov0" title="0">{
                                                return false
                                        }</span>
                                        // Otherwise, if CV17 is valid, set bit 5 and enable it
                                        <span class="cov0" title="0">d.address = append(d.address[:0], 0xC0|d.cv.CV(17))
                                        d.address = append(d.address, d.cv.CV(18))</span>
                                } else<span class="cov0" title="0"> {
                                        // If CV17 is invalid, reject the CV29 update
                                        return false
                                }</span>
                        } else<span class="cov0" title="0"> {
                                // Clear bit 5 and use the short address
                                d.address = append(d.address[:0], d.cv.CV(1))
                                return false
                        }</span>
                case 33:<span class="cov0" title="0">
                        // Configure function mapping to output F0f
                        d.outputMapsFwd[0] = uint16(value)</span>
                case 34:<span class="cov0" title="0">
                        // Configure function mapping to output F0r
                        d.outputMapsRev[0] = uint16(value)</span>
                case 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46:<span class="cov0" title="0">
                        // Configure function mapping for F1-F12 to outputs AUX1-AUX12 (fwd and rev)
                        outputNum := cvNumber - 34
                        outputs := uint16(value)
                        if cvNumber &gt;= 43 </span><span class="cov0" title="0">{
                                // AUX5-AUX12
                                outputs = outputs &lt;&lt; 6
                        }</span> else<span class="cov0" title="0"> if cvNumber &gt;= 38 </span><span class="cov0" title="0">{
                                // AUX2-AUX9
                                outputs = outputs &lt;&lt; 3
                        }</span>
                        <span class="cov0" title="0">d.outputMapsFwd[outputNum] = outputs</span>
                }

                <span class="cov0" title="0">return true</span>
        }
}

/* TODO: Might be useful?
// SetSampleFrequency sets the sample frequency of the I2S peripheral.
func (d *DCCReader) SetFrequency(freq uint32) error {
        freq *= 32 // 32 bits per sample
        whole, frac, err := pio.ClkDivFromFrequency(freq, machine.CPUFrequency())
        if err != nil {
                return err
        }
        i2s.sm.SetClkDiv(whole, frac)
        return nil
}
*/
</pre>
		
		<pre class="file" id="file6" style="display: none">//go:build !rp

package dcc

import "github.com/mikesmitty/rp24-dcc-decoder/internal/shared"

// initPIO is a stub for non-RP platforms
func (d *Decoder) initPIO(pioNum int, pin shared.Pin) error <span class="cov0" title="0">{
        return nil
}</span>

func (d *Decoder) BasicAck() {<span class="cov0" title="0">
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package dcc

import (
        "github.com/mikesmitty/rp24-dcc-decoder/internal/shared"
        "github.com/mikesmitty/rp24-dcc-decoder/pkg/motor"
)

func (d *Decoder) RegisterOutput(output string, fn shared.OutputCallback) <span class="cov0" title="0">{
        index := IndexFromOutput(output)
        d.outputCallbacks[index] = append(d.outputCallbacks[index], fn)
}</span>

// Control DCC functions
func (d *Decoder) callFunction(number uint16, on bool) <span class="cov8" title="1">{
        var ok bool
        // If there's no separate reverse callback use forward instead
        outputMap, hasReverse := d.outputMapsRev[number]
        direction := d.motor.Direction()
        if direction == motor.Forward || !hasReverse </span><span class="cov8" title="1">{
                outputMap, ok = d.outputMapsFwd[number]
        }</span>
        <span class="cov8" title="1">if !ok </span><span class="cov8" title="1">{
                return
        }</span>

        // If the direction has changed from reverse to forward and this function has separate forward/reverse
        // output maps turn off the outputs that would have been on in reverse. Not needed if there's no
        // separate reverse output map, as the forward map is used for both directions
        <span class="cov0" title="0">if d.lastDirection != direction &amp;&amp; hasReverse </span><span class="cov0" title="0">{
                d.lastDirection = direction

                outputMapPrev := d.outputMapsRev[number]
                if direction == motor.Reverse </span><span class="cov0" title="0">{
                        outputMapPrev = d.outputMapsFwd[number]
                }</span>
                <span class="cov0" title="0">for i := range 16 </span><span class="cov0" title="0">{
                        if outputMapPrev&amp;(1&lt;&lt;i) != 0 </span><span class="cov0" title="0">{
                                // Turn off all the "on" outputs from the previous direction
                                if handlers, ok := d.outputCallbacks[number]; ok </span><span class="cov0" title="0">{
                                        for _, fn := range handlers </span><span class="cov0" title="0">{
                                                fn(outputMap, false)
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov0" title="0">for i := range 16 </span><span class="cov0" title="0">{
                if outputMap&amp;(1&lt;&lt;i) != 0 </span><span class="cov0" title="0">{
                        if handlers, ok := d.outputCallbacks[number]; ok </span><span class="cov0" title="0">{
                                for _, fn := range handlers </span><span class="cov0" title="0">{
                                        fn(number, on)
                                }</span>
                        }
                }
        }
}

func IndexFromOutput(output string) uint16 <span class="cov0" title="0">{
        // TODO: Switch away from strings?
        switch output </span>{
        case "lampFront":<span class="cov0" title="0">
                return 0</span>
        case "lampRear":<span class="cov0" title="0">
                return 1</span>
        case "aux1":<span class="cov0" title="0">
                return 2</span>
        case "aux2":<span class="cov0" title="0">
                return 3</span>
        case "aux3":<span class="cov0" title="0">
                return 4</span>
        case "aux4":<span class="cov0" title="0">
                return 5</span>
        case "aux5":<span class="cov0" title="0">
                return 6</span>
        case "aux6":<span class="cov0" title="0">
                return 7</span>
        case "aux7":<span class="cov0" title="0">
                return 8</span>
        case "aux8":<span class="cov0" title="0">
                return 9</span>
        case "aux10":<span class="cov0" title="0">
                return 10</span>
        case "aux11":<span class="cov0" title="0">
                return 11</span>
        case "aux12":<span class="cov0" title="0">
                return 12</span>
        }
        <span class="cov0" title="0">return 255</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package dcc

import (
        "github.com/mikesmitty/rp24-dcc-decoder/pkg/cv"
        "github.com/mikesmitty/rp24-dcc-decoder/pkg/motor"
)

type MessageType int

const (
        UnknownMsg MessageType = iota
        ServiceMsg
        ExtendedMsg
        AdvancedExtendedMsg
)

type AddressType int

const (
        UnknownAddress AddressType = iota
        BroadcastAddress
        DirectAddress
        ConsistAddress
        IdleAddress
)

type Message struct {
        addr    AddressType
        buf     []byte
        msgType MessageType

        cv      cv.Handler
        decoder *Decoder

        cvConfirm map[uint16]uint8
        lastXPOM  []byte
}

func NewMessage(cvHandler cv.Handler, decoder *Decoder) *Message <span class="cov8" title="1">{
        return &amp;Message{
                buf:       make([]byte, 0, maxMsgLength),
                cv:        cvHandler,
                cvConfirm: make(map[uint16]uint8),
                decoder:   decoder,
                lastXPOM:  make([]byte, 0, 8),
        }
}</span>

func (m *Message) AddByte(b byte) <span class="cov8" title="1">{
        m.buf = append(m.buf, b)
}</span>

func (m *Message) AddBytes(b []byte) <span class="cov8" title="1">{
        m.buf = append(m.buf, b...)
}</span>

func (m *Message) Bytes() []byte <span class="cov8" title="1">{
        return m.buf
}</span>

func (m *Message) Reset() <span class="cov8" title="1">{
        m.buf = m.buf[:0]
        m.msgType = UnknownMsg
}</span>

func (m *Message) XOR() bool <span class="cov8" title="1">{
        var xor byte
        for _, b := range m.buf </span><span class="cov8" title="1">{
                xor ^= b
        }</span>
        <span class="cov8" title="1">return xor == 0</span>
}

func (m *Message) IsEmpty() bool <span class="cov8" title="1">{
        return len(m.buf) == 0
}</span>

func (m *Message) IsFull() bool <span class="cov8" title="1">{
        return len(m.buf) == cap(m.buf)
}</span>

func (m *Message) Length() int <span class="cov8" title="1">{
        return len(m.buf)
}</span>

func (m *Message) Process() <span class="cov0" title="0">{
        if !m.decoder.Snoop &amp;&amp; (!m.checkAddress() || m.addr == UnknownAddress) </span><span class="cov0" title="0">{
                // Ignore messages not addressed to us if we're not being nosy
                return
        }</span>

        // Check the message type to determine how to handle it
        <span class="cov0" title="0">m.msgType = m.messageType()

        // packetType := "" // FIXME: Cleanup
        ok := false
        switch m.msgType </span>{
        case ServiceMsg:<span class="cov0" title="0">
                ok = m.serviceModePacket()</span>
                // packetType = "Svc " // FIXME: Cleanup
                // if ok { // FIXME: Cleanup
                //         print("1 ")
                // } else {
                //         print("0 ")
                // }
                // for _, b := range m.Bytes() {
                //         fmt.Printf("%08b ", b)
                // }
                // println("")
        case ExtendedMsg:<span class="cov0" title="0">
                ok = m.extendedPacket()</span>
                // packetType = "Ext " // FIXME: Cleanup
        case AdvancedExtendedMsg:<span class="cov0" title="0">
                ok = m.advancedExtendedPacket()</span>
                // packetType = "Adv " // FIXME: Cleanup
        default:<span class="cov0" title="0">
                // Unknown message type
                return</span> // FIXME: Is this correct?
        }

        <span class="cov0" title="0">if ok </span><span class="cov0" title="0">{
                m.decoder.BasicAck()
                // FIXME: Advanced Ack usage?
                // m.decoder.AdvancedAck([]byte{ackByte}, []byte{})
                // } else {
                //         // FIXME: Cleanup
                //         // print(packetType) // FIXME: Cleanup
                //         for _, b := range m.Bytes() {
                //                 fmt.Printf("%08b ", b)
                //         }
                //         println("")
        }</span>

        // respByte := nackByte
        // if ok {
        //         respByte = ackByte
        // }
        // err := m.decoder.AdvancedAck([]byte{respByte}, []byte{})
        // if err != nil {
        //         // println("Error sending ack:", err.Error()) // FIXME: Cleanup
        // }
}

func (m *Message) messageType() MessageType <span class="cov8" title="1">{
        b := m.buf[0]

        if m.decoder.opMode == ServiceMode || m.decoder.svcModeReady </span><span class="cov8" title="1">{
                if b &gt;= 112 &amp;&amp; b &lt;= 127 </span><span class="cov8" title="1">{
                        // Received a service mode packet
                        return ServiceMsg
                }</span> else<span class="cov0" title="0"> {
                        // Ignore non-service mode packets while in service mode
                        return UnknownMsg
                }</span>
        }

        <span class="cov8" title="1">if b &lt; 128 || b &gt;= 192 &amp;&amp; b &lt;= 231 </span><span class="cov8" title="1">{
                // Extended message format
                return ExtendedMsg
        }</span> else<span class="cov8" title="1"> if b == 253 || b == 254 </span><span class="cov8" title="1">{
                // Advanced extended message format
                return AdvancedExtendedMsg
        }</span>
        // We're intentionally ignoring accessory decoder messages for now, may implement later
        // Basic messages are superseded by extended messages
        <span class="cov8" title="1">return UnknownMsg</span>
}

func (m *Message) motionCommand(bytes []byte) (uint8, bool, bool) <span class="cov8" title="1">{
        if len(bytes) &gt; 1 &amp;&amp; m.decoder.motor.SpeedMode() == motor.SpeedMode14 </span><span class="cov0" title="0">{
                // We're configured for 14 speed mode, ignore 128 speed commands
                return 1, false, false
        }</span>

        <span class="cov8" title="1">var speed uint8
        var reverse bool

        switch len(bytes) </span>{
        case 1:<span class="cov8" title="1">
                speed = uint8(bytes[0] &amp; 0x0F)
                reverse = (bytes[0] &amp; 0b00100000) == 0
                if m.decoder.motor.SpeedMode() == motor.SpeedMode14 </span>{<span class="cov8" title="1">
                        // 14-speed mode: 01DCSSSS
                        // D: Direction (0 = reverse, 1 = forward)
                        // S: Speed step (0-15)
                        // C: Ignored
                        // No changes needed
                }</span> else<span class="cov8" title="1"> {
                        // 28-speed mode: 01DLSSSS
                        // D: Direction (0 = reverse, 1 = forward)
                        // L: Low bit
                        // S: Speed step (0-27)
                        speed = speed&lt;&lt;1 | (bytes[0] &gt;&gt; 4 &amp; 1)
                        if speed &lt; 4 </span><span class="cov8" title="1">{
                                // Stop and emergency stop ignore the extra low bit value
                                speed = bytes[0] &amp; 0x01
                        }</span> else<span class="cov8" title="1"> {
                                speed -= 2
                        }</span>
                        // 28/128 speed modes are selected by the last speed command received
                        <span class="cov8" title="1">m.decoder.motor.SetSpeedMode(motor.SpeedMode28)</span>
                }
        case 2:<span class="cov8" title="1">
                if bytes[0] == 0b00111111 </span><span class="cov8" title="1">{
                        // 128-speed mode: 00111111 DSSSSSSS
                        // D: Direction (0 = reverse, 1 = forward)
                        // S: Speed step (0-127)
                        speed = bytes[1] &amp; 0x7F
                        reverse = (bytes[1] &amp; 0x80) == 0

                        // 28/128 speed modes are selected by the last speed command received
                        m.decoder.motor.SetSpeedMode(motor.SpeedMode128)
                }</span> else<span class="cov0" title="0"> {
                        // Invalid speed mode
                        return 1, false, false
                }</span>
        default:<span class="cov0" title="0">
                println("Invalid speed command length")
                return 1, false, false</span>
        }

        <span class="cov8" title="1">return speed, reverse, true</span>
}

func (m *Message) checkAddress() bool <span class="cov8" title="1">{
        switch m.buf[0] </span>{
        case 0x00:<span class="cov8" title="1">
                // Broadcast address
                m.addr = BroadcastAddress
                return true</span>
        case 0xFF:<span class="cov8" title="1">
                // Idle packet, ignore
                m.addr = IdleAddress</span>
                // TODO: Idle packets count as valid data packets to return to operations mode, I think?
        case 253, 254:<span class="cov0" title="0"></span>
                // Advanced extended packet format, not supported yet
        default:<span class="cov8" title="1">
                // We don't know how to interprest accessory decoder messages
                if m.buf[0] &gt;= 128 &amp;&amp; m.buf[0] &lt;= 191 </span><span class="cov0" title="0">{
                        m.addr = UnknownAddress
                        return false
                }</span>

                // Check for direct or consist address match
                <span class="cov8" title="1">if m.addressMatch(m.decoder.address) </span><span class="cov8" title="1">{
                        m.addr = DirectAddress
                        return true
                }</span> else<span class="cov8" title="1"> if m.addressMatch(m.decoder.consistAddress) </span><span class="cov8" title="1">{
                        m.addr = ConsistAddress
                        return true
                }</span>

                // TODO: Differentiate recognized message types with unrecognized addresses while snooping?
                // TODO: Remove snooping once address setting is done being implemented
                // No recognized addresses
                <span class="cov8" title="1">m.addr = UnknownAddress
                // If we're snooping that's okay anyway
                return m.decoder.Snoop</span>
        }
        <span class="cov8" title="1">return false</span>
}

// addressMatch checks if the first bytes of the message match the provided buffer
func (m *Message) addressMatch(b []byte) bool <span class="cov8" title="1">{
        if len(b) &gt; len(m.buf) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">for i, v := range b </span><span class="cov8" title="1">{
                if m.buf[i] != v </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package dcc

func (m *Message) advancedExtendedPacket() bool <span class="cov0" title="0">{
        // TODO: To be implemented
        return false
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package dcc

func (m *Message) extendedPacket() bool <span class="cov8" title="1">{
        // Extended message format
        l := len(m.buf)

        // First command byte
        fb := 1
        switch m.addr </span>{
        case BroadcastAddress:<span class="cov8" title="1"></span>
                // Broadcast address is always 1 byte, no change
        case DirectAddress:<span class="cov8" title="1">
                fb = len(m.decoder.address)</span>
        case ConsistAddress:<span class="cov8" title="1">
                fb = len(m.decoder.consistAddress)</span>
        }

        // Command type is in the top 3 bits of the first command byte
        <span class="cov8" title="1">switch m.buf[fb] &gt;&gt; 5 </span>{
        case 0b000:<span class="cov8" title="1">
                return m.decoderConsistControlInstruction(m.buf[fb : l-1])</span>
        case 0b001:<span class="cov8" title="1">
                return m.advancedOperationInstruction(m.buf[fb : l-1])</span>
        case 0b010, 0b011:<span class="cov8" title="1">
                // Speed and Direction Instruction
                speed, reverse, ok := m.motionCommand(m.buf[fb : l-1])
                if ok </span><span class="cov8" title="1">{
                        m.decoder.motor.SetSpeed(speed, reverse)
                }</span>
                <span class="cov8" title="1">return ok</span>
        case 0b100:<span class="cov8" title="1">
                return m.functionGroupOneInstruction(m.buf[fb])</span>
        case 0b101:<span class="cov8" title="1">
                return m.functionGroupTwoInstruction(m.buf[fb])</span>
        case 0b110:<span class="cov8" title="1">
                return m.featureExpansion(m.buf[fb : l-1])</span>
        case 0b111:<span class="cov8" title="1">
                // Don't allow editing CVs from consist-addressed messages
                if m.addr == ConsistAddress </span><span class="cov8" title="1">{
                        return false
                }</span>
                <span class="cov8" title="1">return m.configVariableAccessInstruction(m.buf[fb : l-1])</span>
        }
        <span class="cov0" title="0">return false</span>
}

func (m *Message) decoderConsistControlInstruction(b []byte) bool <span class="cov8" title="1">{
        l := len(b)
        switch b[0] &gt;&gt; 4 </span>{
        // 0b0000xxxx
        case 0b0000:<span class="cov8" title="1">
                // Decoder control 0000xxxx
                switch b[0] </span>{
                case 0b00000000:<span class="cov8" title="1">
                        if l == 1 &amp;&amp; m.addr == BroadcastAddress </span><span class="cov8" title="1">{
                                println("reset packet received")
                                m.decoder.Reset()
                                return true
                        }</span>
                case 0b00000001:<span class="cov8" title="1">
                        // Decoder hard reset packet
                        m.cv.Reset(29)
                        m.cv.Reset(31)  // CV257-512 index
                        m.cv.Reset(32)  // CV257-512 index
                        m.cv.Set(19, 0) // Consist address
                        m.decoder.Reset()
                        return true</span>
                case 0b00000010, 0b00000011:<span class="cov0" title="0"></span>
                        // Factory test mode, not supported
                case 0b00001010, 0b00001011:<span class="cov8" title="1">
                        // Set advanced addressing mode (CV29 bit 5)
                        cv29 := m.cv.CV(29)
                        return m.cv.Set(29, (cv29&amp;^0b00100000)|(b[0]&amp;1)&lt;&lt;5)</span>
                case 0b00001111:<span class="cov0" title="0"></span>
                        // Decoder ack request
                        // FIXME: Implement
                }
        // 0b0001xxxx
        case 0b0001:<span class="cov8" title="1">
                /* Consist control 0001xxxx
                TODO: Implement the other logic:
                When Consist Control is in effect, the decoder will ignore any speed or direction instructions
                addressed to its normal locomotive address (unless this address is the same as its consist address).
                190 Speed and direction instructions now apply to the consist address only

                Functions controlled by Function Group One (100) and Function Group Two (101) will continue to
                respond to the decoder’s baseline address. Functions controlled by instructions 100 and 101 also
                respond to the consist address if the appropriate bits in CVs 21 and 22 have been activated.

                By default, all forms of Bi-directional communication are not activated in response to commands
                sent to the consist address until specifically activated by a Decoder Control instruction.

                https://www.nmra.org/sites/default/files/standards/sandrp/DCC/S/s-9.2.1_dcc_extended_packet_formats.pdf
                Page 5
                */
                switch b[0] </span>{
                case 0b00010010:<span class="cov8" title="1">
                        // Set consist address
                        if l &gt; 1 &amp;&amp; b[1] &lt; 128 </span><span class="cov8" title="1">{
                                return m.cv.Set(19, b[1])
                        }</span>
                case 0b00010011:<span class="cov8" title="1">
                        // Set consist address and reverse direction
                        if l &gt; 1 </span><span class="cov8" title="1">{
                                return m.cv.Set(19, b[1]|0x80)
                        }</span>
                }
        }
        <span class="cov0" title="0">return false</span>
}

func (m *Message) advancedOperationInstruction(b []byte) bool <span class="cov8" title="1">{
        // 0b001xxxxx
        // 128-step speed control
        switch b[0] </span>{
        case 0b00111111:<span class="cov8" title="1">
                speed, reverse, ok := m.motionCommand(b)
                if ok </span><span class="cov8" title="1">{
                        m.decoder.motor.SetSpeed(speed, reverse)
                }</span>
                <span class="cov8" title="1">return ok</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}

func (m *Message) functionGroupOneInstruction(b uint8) bool <span class="cov8" title="1">{
        // Function Group One Instruction
        // 100DDDDD
        // If message was sent to the consist address, ignore function values according to CVs 21 and 22
        if m.addr == ConsistAddress </span><span class="cov0" title="0">{
                b &amp;= m.decoder.consistFuncMask[0]
        }</span>
        // FL (F0)
        <span class="cov8" title="1">m.decoder.callFunction(0, b&amp;(1&lt;&lt;4) != 0)
        // F1-F4
        for i := range uint16(4) </span><span class="cov8" title="1">{
                m.decoder.callFunction(i+1, b&amp;(1&lt;&lt;i) != 0)
        }</span>
        <span class="cov8" title="1">return true</span>
}

func (m *Message) functionGroupTwoInstruction(b uint8) bool <span class="cov8" title="1">{
        // Function Group Two Instruction
        // 101SDDDD
        // Bit 4 (S) is a shift bit. If set to 1, bits 0-3 (D) are F5-F8. If set to 0, bits 0-3 are F9-F12
        offset := uint16(5)
        mask := m.decoder.consistFuncMask[1]
        if b&amp;(1&lt;&lt;4) == 0 </span><span class="cov8" title="1">{
                offset = 9
                mask = m.decoder.consistFuncMask[2]
        }</span>
        // If message was sent to the consist address, ignore function values according to CVs 21 and 22
        <span class="cov8" title="1">if m.addr == ConsistAddress </span><span class="cov0" title="0">{
                b &amp;= mask
        }</span>
        <span class="cov8" title="1">for i := range uint16(4) </span><span class="cov8" title="1">{
                m.decoder.callFunction(i+offset, b&amp;(1&lt;&lt;i) != 0)
        }</span>
        <span class="cov8" title="1">return true</span>
}

func (m *Message) functionGroupNInstruction(n uint16, b uint8) bool <span class="cov8" title="1">{
        // Function Group N Instruction
        // Each bit in the command byte represents a function (starting with F13)
        for i := range uint16(8) </span><span class="cov8" title="1">{
                m.decoder.callFunction(i+n, b&amp;(1&lt;&lt;i) != 0)
        }</span>
        <span class="cov8" title="1">return true</span>
}

func (m *Message) featureExpansion(b []byte) bool <span class="cov8" title="1">{
        // Feature Expansion Instruction
        // 110GGGGG DDDDDDDD [DDDDDDDD]
        switch b[0] </span>{
        case 0b11000000:<span class="cov8" title="1"></span>
        // Binary state control long form
        // 32,767 binary states, 0 resets all states to off
        // 11000000 DLLLLLLL HHHHHHHH
        // L = 7-bit low byte
        // H = optional 8-bit high byte (treated as 0 if not present)
        // D = data bit
        // TODO: Implement
        case 0b11000001:<span class="cov0" title="0"></span>
        // Model time and date command
        // Not supported at this time, possibly in the future
        case 0b11000010:<span class="cov0" title="0"></span>
        // System time (0-65535 milliseconds)
        // Not supported at this time, possibly in the future
        case 0b11011101:<span class="cov0" title="0"></span>
        // Binary state control short form
        // 127 binary states, 0 resets all states to off
        // 11011101 DLLLLLLL
        // L = 7-bit low byte
        // D = data bit
        // TODO: Implement
        case 0b11011110:<span class="cov8" title="1">
                // Functions F13-F20
                return m.functionGroupNInstruction(13, b[1])</span>
        case 0b11011111:<span class="cov8" title="1">
                // Functions F21-F28
                return m.functionGroupNInstruction(21, b[1])</span>
        case 0b11011000:<span class="cov8" title="1">
                // Functions F29-F36
                return m.functionGroupNInstruction(29, b[1])</span>
        case 0b11011001:<span class="cov8" title="1">
                // Functions F37-F44
                return m.functionGroupNInstruction(37, b[1])</span>
        case 0b11011010:<span class="cov8" title="1">
                // Functions F45-F52
                return m.functionGroupNInstruction(45, b[1])</span>
        case 0b11011011:<span class="cov8" title="1">
                // Functions F53-F60
                return m.functionGroupNInstruction(53, b[1])</span>
        case 0b11011100:<span class="cov8" title="1">
                // Functions F61-F68
                return m.functionGroupNInstruction(61, b[1])</span>
        }
        <span class="cov8" title="1">return false</span>
}

func (m *Message) configVariableAccessInstruction(b []byte) bool <span class="cov8" title="1">{
        l := len(b)
        // All CV access commands are at least 2 bytes
        if l &lt; 2 </span><span class="cov8" title="1">{
                return false
        }</span>
        // Long form - 1110xxxx
        <span class="cov8" title="1">if b[0]&amp;0xF0 == 0xE0 </span><span class="cov8" title="1">{
                if l == 3 </span><span class="cov8" title="1">{
                        // Format is 1110CCAA AAAAAAAA DDDDDDDD
                        return m.cvCommand(m.cv.IndexPage(), b)
                }</span> else<span class="cov8" title="1"> if l &gt; 3 </span><span class="cov8" title="1">{
                        // XPOM - Extended Programming On Main
                        // Up to 8 bytes plus short/long address and checksum (max 11 bytes)
                        // 1110GGSS VVVVVVVV VVVVVVVV VVVVVVVV [DDDDDDDD [DDDDDDDD [DDDDDDDD [DDDDDDDD]]]]
                        return m.handleXPOM(b)
                }</span>
        } else<span class="cov8" title="1"> {
                // Short form - 1111xxxx
                switch b[0] </span>{
                case 0b11110010:<span class="cov8" title="1">
                        // CV23 Acceleration rate adjustment
                        return m.cv.Set(23, b[1])</span>
                case 0b11110011:<span class="cov8" title="1">
                        // CV24 Deceleration rate adjustment
                        return m.cv.Set(24, b[1])</span>
                case 0b11110100:<span class="cov8" title="1">
                        // Extended address programming (CV17, CV18, CV29)
                        // Must receive two identical packets to confirm before setting
                        if l &lt; 3 </span><span class="cov8" title="1">{
                                return false
                        }</span>
                        // Check for confirmed values
                        <span class="cov8" title="1">if m.cvConfirmCheck(17, b[1]) &amp;&amp; m.cvConfirmCheck(18, b[2]) </span><span class="cov8" title="1">{
                                // Values confirmed, set the CVs
                                cv29 := m.cv.CV(29) &amp;^ (1 &lt;&lt; 5) // Clear bit 5
                                if b[1] &gt;= 192 &amp;&amp; b[1] &lt;= 231 </span><span class="cov8" title="1">{
                                        // If CV17 is valid, set bit 5 to enable it
                                        cv29 |= 1 &lt;&lt; 5
                                }</span>
                                <span class="cov8" title="1">return m.cv.Set(17, b[1]) &amp;&amp;
                                        m.cv.Set(18, b[2]) &amp;&amp;
                                        m.cv.Set(29, cv29)</span>
                        } else<span class="cov8" title="1"> {
                                // cvConfirmCheck will store the values for the next packet
                                return true
                        }</span>
                case 0b11110101:<span class="cov8" title="1">
                        // Indexed CVs (CV257-512), set CV31/32 index values
                        // Must receive two identical packets to confirm before setting
                        if l &lt; 3 || b[1] &lt; 16 </span><span class="cov8" title="1">{
                                // CV31 values &lt; 16 are reserved
                                return false
                        }</span>
                        // Check for confirmed values
                        <span class="cov8" title="1">if m.cvConfirmCheck(31, b[1]) &amp;&amp; m.cvConfirmCheck(32, b[2]) </span><span class="cov8" title="1">{
                                // Values confirmed, load the new index
                                err := m.cv.LoadIndex(b[1], b[2])
                                if err != nil </span><span class="cov0" title="0">{
                                        println("could not load index: " + err.Error())
                                        return false
                                }</span>
                                <span class="cov8" title="1">return true</span>
                        } else<span class="cov8" title="1"> {
                                // cvConfirmCheck will store the values for the next packet
                                return true
                        }</span>
                case 0b11110110:<span class="cov8" title="1">
                        // Consist extended address
                        // Must receive two identical packets to confirm before setting
                        if l &lt; 3 </span><span class="cov8" title="1">{
                                return false
                        }</span>
                        // Check for confirmed values
                        <span class="cov8" title="1">if m.cvConfirmCheck(19, b[1]) &amp;&amp; m.cvConfirmCheck(20, b[2]) </span><span class="cov8" title="1">{
                                // Values confirmed, set the CVs
                                return m.cv.Set(19, b[1]) &amp;&amp; m.cv.Set(20, b[2])
                        }</span> else<span class="cov8" title="1"> {
                                // cvConfirmCheck will store the values for the next packet
                                return true
                        }</span>
                case 0b11111001:<span class="cov0" title="0"></span>
                        // Service Mode Decoder Lock S-9.2.3 Appendix B
                        // Not implemented
                }
        }

        <span class="cov8" title="1">return false</span>
}

// Confirm we've received the same value for a CV twice before setting it
func (m *Message) cvConfirmCheck(cv uint16, value uint8) bool <span class="cov8" title="1">{
        value, ok := m.cvConfirm[cv]
        if ok &amp;&amp; value == value </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">m.cvConfirm[cv] = value
        return false</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package dcc

func (m *Message) serviceModePacket() bool <span class="cov0" title="0">{
        m.decoder.SetOpMode(ServiceMode)
        /* TODO: Implement the ability to leave service mode
        For now, service mode is hotel california. We'll depend on losing power to return to operations mode
        if time.Now().Sub(m.decoder.lastSvcResetTime) &gt; 20*time.Millisecond {
                // If it's been more than 20ms since the last reset packet, service mode is no longer ready, back to operations mode
                // Check to ensure we didn't receive a service mode packet before switching back to operations mode per S-9.2.3C
                //m.decoder.SetOpMode(UndefinedMode)
                return
        } */

        ack := false

        // Direct CV Addressing commands
        // 0111CCAA AAAAAAAA DDDDDDDD EEEEEEEE
        if m.buf[0]&amp;0b11110000 == 0b01110000 </span><span class="cov0" title="0">{
                // CV access/programming command
                ack = m.cvCommand(m.cv.IndexPage(), m.buf)
        }</span>

        <span class="cov0" title="0">return ack</span>
}

func (m *Message) cvCommand(index uint16, b []byte) bool <span class="cov8" title="1">{
        // CV programming command format
        // C = command type, A = address, D = data
        // C: 01 = verify, 11 = write byte
        // xxxxCCAA AAAAAAAA DDDDDDDD
        //
        // C: 10 = bit manipulation
        // F: 0 = verify, 1 = write
        // D: bit value
        // B: bit position
        // xxxxCCAA AAAAAAAA 111FDBBB

        op := (b[0] &gt;&gt; 2) &amp; 0b11                         // CC
        cvNum := uint16(b[0]&amp;0b11)&lt;&lt;8 | uint16(b[1]) + 1 // AA AAAAAAAA (n-1, CV1 = 0)
        data := b[2]                                     // DDDDDDDD

        ack := false
        switch op </span>{
        case 0b01:<span class="cov8" title="1">
                // Verify byte
                if v, ok := m.cv.IndexedCVOk(index, cvNum); ok &amp;&amp; v == data </span><span class="cov8" title="1">{
                        ack = true
                }</span>
        case 0b10:<span class="cov8" title="1">
                // Bit manipulation (write/verify bit)
                if data&amp;0b11100000 != 0b11100000 </span><span class="cov8" title="1">{
                        // Invalid command
                        return false
                }</span>
                <span class="cov8" title="1">pos := data &amp; 0b111
                bit := (data &gt;&gt; 3) &amp; 1
                v, ok := m.cv.IndexedCVOk(index, cvNum)

                if data&amp;0b10000 == 0 </span><span class="cov8" title="1">{
                        // Verify
                        if ok &amp;&amp; (v&gt;&gt;pos)&amp;1 == bit </span><span class="cov8" title="1">{
                                ack = true
                        }</span>
                } else<span class="cov8" title="1"> if ok </span><span class="cov8" title="1">{
                        // Write
                        if ok := m.cv.IndexedSetSync(index, cvNum, (v&amp;^(1&lt;&lt;pos))|(bit&lt;&lt;pos)); ok </span><span class="cov8" title="1">{
                                ack = true
                        }</span> else<span class="cov0" title="0"> {
                                println("CV write error")
                        }</span>
                } else<span class="cov8" title="1"> {
                        println("CV not found")
                }</span>
        case 0b11:<span class="cov8" title="1">
                // Write byte
                if ok := m.cv.IndexedSetSync(index, cvNum, data); ok </span><span class="cov8" title="1">{
                        ack = true
                }</span> else<span class="cov8" title="1"> {
                        println("CV write error")
                }</span>
        }
        <span class="cov8" title="1">return ack</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package dcc

func (m *Message) handleXPOM(b []byte) bool <span class="cov8" title="1">{
        // XPOM - Extended Programming On Main
        // Up to 8 bytes plus short/long address and checksum (max 11 bytes)
        // Two identical packets must be received to confirm correctness

        // All XPOM commands are at least 4 bytes
        if len(b) &lt; 4 </span><span class="cov0" title="0">{
                return false
        }</span>

        // Don't process XPOM commands addressed to the consist address
        <span class="cov8" title="1">if m.addr == ConsistAddress </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check for identical packets
        <span class="cov8" title="1">match := false
        if len(b) == len(m.lastXPOM) </span><span class="cov0" title="0">{
                match = true
                for i, v := range b </span><span class="cov0" title="0">{
                        if v != m.lastXPOM[i] </span><span class="cov0" title="0">{
                                match = false
                                break</span>
                        }
                }
        }
        // If we don't have a match, store this one and wait for the next
        // Technically any addressed messages received including broadcasts should invalidate
        // lastXPOM but for now we'll just make sure the last received XPOM message is identical
        <span class="cov8" title="1">if !match </span><span class="cov8" title="1">{
                m.lastXPOM = m.lastXPOM[:0]
                for _, v := range b </span><span class="cov8" title="1">{
                        m.lastXPOM = append(m.lastXPOM, v)
                }</span>
                <span class="cov8" title="1">return false</span>
        }

        // 1110CCSS AAAAAAAA AAAAAAAA AAAAAAAA [DDDDDDDD [DDDDDDDD [DDDDDDDD [DDDDDDDD]]]]
        // CC = Command
        // SS = Sequence number
        // A = CV Number (CV31 index, CV32 index, Relative CV Number)
        // D = Data

        // Commands:
        // 01 = read bytes
        // 11 = write bytes
        // 10 = write bits

        // seq := b[0] &amp; 0b11 // TODO: What is this for?
        // Find in https://www.nmra.org/sites/default/files/standards/sandrp/Draft/DCC/s-9.3.2_bi-directional_communication.pdf
        <span class="cov0" title="0">index := m.cv.IndexPage(b[1], b[2])
        switch (b[0] &gt;&gt; 2) &amp; 0b11 </span>{
        case 0b01:<span class="cov0" title="0"></span>
                // Read bytes
                // All XPOM commands respond with four consecutive CV values
                // This one just doesn't write anything
        case 0b11:<span class="cov0" title="0">
                // Write bytes
                for i, v := range b[4:] </span><span class="cov0" title="0">{
                        if !m.cv.IndexedSet(index, uint16(b[3])+uint16(i), v) </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
        case 0b10:<span class="cov0" title="0">
                // Write bits
                if len(b) &lt; 5 </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">m.cvCommand(index, b[3:])</span>
        }

        // Return the four bytes via BiDi communication
        <span class="cov0" title="0">for i := range uint16(4) </span><span class="cov0" title="0">{
                // FIXME: Do BiDi communication
                m.cv.IndexedCV(index, uint16(b[3])+i)
        }</span>

        <span class="cov0" title="0">return true</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package dcc

import (
        "runtime"
        "time"
)

func (d *Decoder) Monitor() <span class="cov0" title="0">{
        // The earlier rev rp2350 decoder's smoothing cap adds ~6us to one half-wave
        // TODO: Make this configurable
        delay := uint32(6)

        tr1Min := tr1MinTime + delay
        tr1Max := tr1MaxTime + delay
        tr0Min := tr0MinTime + delay
        tr0Max := tr0MaxTime + delay

        var bit int
        var out byte

        msg := NewMessage(d.cv, d)

        i := 0
        state := Preamble
        for </span><span class="cov0" title="0">{
                // Save the wave time readings in the ring buffer so we don't lose any
                for !d.sm.IsRxFIFOEmpty() &amp;&amp; !d.buf.Full() </span><span class="cov0" title="0">{
                        d.buf.Put(d.sm.RxGet())
                }</span>
                <span class="cov0" title="0">for d.buf.Used() &gt; 0 </span><span class="cov0" title="0">{
                        // Two cycles per loop / 2 MHz clock = 1 microsecond per tick
                        ticks, ok := d.buf.Get()
                        if !ok </span><span class="cov0" title="0">{
                                // No data available, sleep and wait for more data to be processed
                                break</span>
                        }

                        // Make sure the bit is within the valid ranges
                        <span class="cov0" title="0">bit = 0
                        if ticks &gt;= tr1Min &amp;&amp; ticks &lt;= tr1Max </span><span class="cov0" title="0">{
                                bit = 1
                        }</span> else<span class="cov0" title="0"> if ticks &lt; tr0Min || ticks &gt; tr0Max </span><span class="cov0" title="0">{
                                // Noise
                                continue</span>
                        }

                        // Increment the bit counter
                        <span class="cov0" title="0">i++

                        switch state </span>{
                        case Preamble:<span class="cov0" title="0">
                                // Waiting for the preamble count to be satisfied
                                if bit == 0 </span><span class="cov0" title="0">{
                                        if i &gt;= preambleLength </span><span class="cov0" title="0">{
                                                // Preamble terminator bit received, ready to decode data
                                                state = Bits
                                                i = 0
                                        }</span> else<span class="cov0" title="0"> {
                                                // Reset the bit counter, we got a premature terminating bit
                                                i = 0
                                        }</span>
                                }
                        case Bits:<span class="cov0" title="0">
                                // Shift in a zero bit
                                out &lt;&lt;= 1
                                // Set it to 1
                                if bit == 1 </span><span class="cov0" title="0">{
                                        out |= 1
                                }</span>
                                // Next bit will be a terminator, save byte and prep for the next loop
                                <span class="cov0" title="0">if i == 8 </span><span class="cov0" title="0">{
                                        msg.AddByte(out)
                                        out = 0
                                        state = Terminator
                                }</span>
                        case Terminator:<span class="cov0" title="0">
                                i = 0
                                state = Bits

                                if bit == 1 </span><span class="cov0" title="0">{
                                        // End of message terminator bit received, wait for a preamble next loop
                                        state = Preamble

                                        if !msg.XOR() </span><span class="cov0" title="0">{
                                                // FIXME: Cleanup
                                                // for _, b := range msg.Bytes() {
                                                //         fmt.Printf("%08b ", b)
                                                //         // printByte(b)
                                                //         // print(" ")
                                                // }
                                                println("checksum error")
                                        }</span> else<span class="cov0" title="0"> {
                                                msg.Process()
                                        }</span>

                                        // Reset the message buffer for the next message
                                        <span class="cov0" title="0">msg.Reset()
                                        runtime.Gosched()</span>
                                }
                        default:<span class="cov0" title="0">
                                println("ERROR: invalid decoder state: ", state)
                                state = Preamble
                                msg.Reset()</span>
                        }
                }
                <span class="cov0" title="0">time.Sleep(100 * time.Microsecond)</span> // Sleep a bit to avoid busy-waiting
        }
}

// Print the n leftmost bits of b as a binary number
func printUintN(n int, b uint32) <span class="cov0" title="0">{
        for i := n - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                if b&amp;(1&lt;&lt;i) != 0 </span><span class="cov0" title="0">{
                        print("1")
                }</span> else<span class="cov0" title="0"> {
                        print("0")
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package oldmotor

// Direction returns the current direction of the motor
func (m *Motor) Direction() Direction <span class="cov0" title="0">{
        // Double-reverse or double-forward both equal forward
        if m.reverse == m.ndotReverse </span><span class="cov0" title="0">{
                return Forward
        }</span>
        <span class="cov0" title="0">return Reverse</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">//go:build !rp

package oldmotor

import (
        "github.com/mikesmitty/rp24-dcc-decoder/internal/shared"
        "github.com/mikesmitty/rp24-dcc-decoder/pkg/cv"
        "github.com/mikesmitty/rp24-dcc-decoder/pkg/hal"
)

type Motor struct {
        ndotReverse bool
        reverse     bool
}

func NewMotor(conf cv.Handler, hw *hal.HAL, pinA, pinB, emfA, emfB, adcRef shared.Pin) *Motor <span class="cov0" title="0">{
        return &amp;Motor{}
}</span>

func (m *Motor) SetSpeed(speed uint8, reverse bool) {<span class="cov0" title="0">
}</span>

func (m *Motor) Run() {<span class="cov0" title="0">
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package hal

import "github.com/mikesmitty/rp24-dcc-decoder/internal/shared"

func (h *HAL) PinOk(name string) (shared.Pin, bool) <span class="cov0" title="0">{
        _, ok := h.pins[name]
        return h.pins[name], ok
}</span>

func (h *HAL) Pin(name string) shared.Pin <span class="cov0" title="0">{
        pin, ok := h.pins[name]
        if !ok </span><span class="cov0" title="0">{
                return shared.NoPin
        }</span>
        <span class="cov0" title="0">return pin</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">//go:build !rp

package hal

import "github.com/mikesmitty/rp24-dcc-decoder/internal/shared"

type HAL struct {
        pins map[string]shared.Pin
}

// Stub for non-RP platforms
func NewHAL() *HAL <span class="cov0" title="0">{
        return &amp;HAL{}
}</span>

// initI2SPIO is a stub for non-RP platforms
func (h *HAL) initI2SPIO(_ int, _, _ shared.Pin) (shared.I2S, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func (h *HAL) InitPWM(pin shared.Pin, freq uint64, duty float32) (*SimplePWM, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

type ADC struct{}

func NewADC(pin shared.Pin) *ADC <span class="cov0" title="0">{
        return &amp;ADC{}
}</span>

func (a *ADC) Read() uint16 <span class="cov0" title="0">{
        return 0
}</span>
</pre>
		
		<pre class="file" id="file18" style="display: none">package hal

func (h *HAL) InitI2S() error <span class="cov0" title="0">{
        // LRCLKPin is expected to be BCLKPin + 1
        i2s, err := h.initI2SPIO(0, h.pins["i2sDIN"], h.pins["i2sBLCK"])
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // TODO: Make configurable
        <span class="cov0" title="0">i2s.SetSampleFrequency(44100) // TODO: Use 48kHz or 96kHz for ultrasonic frequencies

        /* TODO: Implement
        i2s.WriteStereo(data)
        }
        */
        return nil</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package hal

import "github.com/mikesmitty/rp24-dcc-decoder/internal/shared"

func (h *HAL) GetOutputCallback(output string) shared.OutputCallback <span class="cov0" title="0">{
        return func(_ uint16, on bool) </span><span class="cov0" title="0">{
                h.SetOutput(output, on)
        }</span>
}

func (h *HAL) SetOutput(output string, state bool) <span class="cov0" title="0">{
        // TODO: Add support for dimming, strobing, etc.
        if pin, ok := h.pins[output]; ok </span><span class="cov0" title="0">{
                pin.Set(state)
        }</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">//go:build !rp

package hal

import "github.com/mikesmitty/rp24-dcc-decoder/internal/shared"

func (s *SimplePWM) Enable(enable bool) {<span class="cov0" title="0">
}</span>

func (s *SimplePWM) SetDuty(duty float32) {<span class="cov0" title="0">
}</span>

func (s *SimplePWM) SetFreq(freq uint64) {<span class="cov0" title="0">
}</span>

type pwm interface {
        Set(channel uint8, value uint64)
        SetPeriod(period uint64) error
        Enable(bool)
        Top() uint32
        Configure(config shared.PWMConfig) error
        Channel(shared.Pin) (uint8, error)
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package iir

type IIRFilter struct {
        Alpha float32
        empty bool
        last  float32
}

func NewIIRFilter(alpha float32) *IIRFilter <span class="cov0" title="0">{
        return &amp;IIRFilter{
                Alpha: alpha,
                empty: true,
                last:  0,
        }
}</span>

func (f *IIRFilter) Filter(values ...float32) float32 <span class="cov0" title="0">{
        if f.empty &amp;&amp; len(values) &gt; 0 </span><span class="cov0" title="0">{
                f.last = values[0]
                f.empty = false
        }</span>
        <span class="cov0" title="0">for _, value := range values </span><span class="cov0" title="0">{
                f.last = f.Alpha*f.last + (1-f.Alpha)*value
        }</span>
        <span class="cov0" title="0">return f.last</span>
}

func (f *IIRFilter) Output() float32 <span class="cov0" title="0">{
        return f.last
}</span>

func (f *IIRFilter) Reset() <span class="cov0" title="0">{
        f.empty = true
        f.last = 0
}</span>
</pre>
		
		<pre class="file" id="file22" style="display: none">package motor

import (
        "runtime"
        "time"

        "github.com/mikesmitty/rp24-dcc-decoder/internal/shared"
        "github.com/mikesmitty/rp24-dcc-decoder/pkg/hal"
        "github.com/mikesmitty/rp24-dcc-decoder/pkg/iir"
)

const (
        emfSettleWait = 100 * time.Microsecond // TODO: Tune these values
        emfReadDelay  = 100 * time.Microsecond
)

func (m *Motor) initBackEMF(emfA, emfB, adcRef shared.Pin) <span class="cov0" title="0">{
        m.emfA = emfA
        m.emfB = emfB
        m.emfTicker = time.NewTicker(emfSettleWait)
        m.emfTimer = time.NewTimer(emfSettleWait)

        // Set up back EMF pins for ADC
        m.iir = iir.NewIIRFilter(m.iirAlpha)
        m.setupADC(m.Direction())
        if adcRef != shared.NoPin </span><span class="cov0" title="0">{
                m.adcRef = hal.NewADC(adcRef)
                m.iirRef = iir.NewIIRFilter(m.iirAlpha)
        }</span>
}

func (m *Motor) setupADC(direction Direction) <span class="cov0" title="0">{
        // Set up back EMF pin for ADC
        pin := m.emfA
        if direction == Reverse </span><span class="cov0" title="0">{
                pin = m.emfB
        }</span>
        <span class="cov0" title="0">m.iir.Reset()
        m.emfADC = hal.NewADC(pin)</span>
}

func (m *Motor) RunEMF() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                time.Sleep(m.emfInterval)
                m.emfValue = m.measureBackEMF()
        }</span>
}

// Measure the back EMF voltage to determine the motor speed
func (m *Motor) measureBackEMF() float32 <span class="cov0" title="0">{
        // Temporarily stop PWM for back EMF measurement
        m.stopMotor()

        // Lock the motor mutex to prevent concurrent access to the motor state
        m.pwmMutex.Lock()

        // Wait for motor to stop
        time.Sleep(100 * time.Millisecond) // TODO: Tune this value

        // Kill time waiting for the motor to stop by measuring the ADC reference
        m.emfTicker.Reset(20 * time.Microsecond)
        m.emfTimer.Reset(emfSettleWait)
PREP:
        for </span><span class="cov0" title="0">{
                select </span>{
                // Wait for the back EMF to settle before measuring
                case &lt;-m.emfTimer.C:<span class="cov0" title="0">
                        // EMF settling time is done, break out of the double loop
                        m.emfTicker.Stop()
                        break PREP</span>
                case &lt;-m.emfTicker.C:<span class="cov0" title="0">
                        // Measure the ADC reference attached to ground to help establish a noise baseline while we wait
                        m.iirRef.Filter(float32(m.adcRef.Read()))</span>
                default:<span class="cov0" title="0">
                        // Allow other tasks to run while waiting
                        runtime.Gosched()</span>
                }
        }

        <span class="cov0" title="0">m.emfTicker.Reset(emfReadDelay)
        m.emfTimer.Reset(m.emfDuration - emfSettleWait)
DONE:
        for </span><span class="cov0" title="0">{
                select </span>{
                // Wait until the end of the PWM cutout period (excluding the already-completed motor settling time)
                case &lt;-m.emfTimer.C:<span class="cov0" title="0">
                        // Cutout period is over, break out of the double loop
                        m.emfTicker.Stop()
                        break DONE</span>
                case &lt;-m.emfTicker.C:<span class="cov0" title="0">
                        // Measure back EMF into the IIR filter and sleep until the next one
                        m.iir.Filter(float32(m.emfADC.Read()))</span>
                default:<span class="cov0" title="0">
                        // Allow other tasks to run while waiting
                        runtime.Gosched()</span>
                }
        }

        // Restore PWM
        <span class="cov0" title="0">m.pwmMutex.Unlock()
        m.ApplyPWM(m.pwmDuty)

        return m.iir.Output() - m.iirRef.Output()</span>
}

func (m *Motor) updateBackEMFTiming() <span class="cov0" title="0">{
        // Calculate the cutout interval and duration in 100us units based on the current speed setting
        m.emfInterval = m.varyBySpeed(m.cv[116], m.cv[117])
        m.emfDuration = m.varyBySpeed(m.cv[118], m.cv[119])
}</span>

// Calculate a varying offset based on the currently commanded speed
func (m *Motor) varyBySpeed(min, max uint8) time.Duration <span class="cov0" title="0">{
        // Calculate the spread of the speed table
        // This is used to calculate the back EMF interval by speed
        step := float32(max-min) / float32(m.speedMode)
        count := time.Duration(float32(min) + float32(m.currentSpeed)*step)
        return count * 100 * time.Microsecond
}</span>
</pre>
		
		<pre class="file" id="file23" style="display: none">package motor

import (
        "github.com/mikesmitty/rp24-dcc-decoder/internal/shared"
)

func (m *Motor) CVCallback() shared.CVCallbackFunc <span class="cov0" title="0">{
        return func(cvNumber uint16, value uint8) bool </span><span class="cov0" title="0">{
                switch cvNumber </span>{
                case 2, 5, 6:<span class="cov0" title="0">
                        // CV2 Vstart (minimum throttle required to start moving)
                        // CV5 Vmax (max throttle)
                        // CV6 Vmid (mid throttle)
                        defer m.updateSpeedTable()</span>

                case 3, 4, 23, 24:<span class="cov0" title="0">
                        // CV3 Acceleration rate
                        // CV4 Deceleration rate
                        // CV23 Consist acceleration modifier
                        // CV24 Consist deceleration modifier
                        defer m.calculateAccelDecelRates()</span>

                case 9:<span class="cov0" title="0">
                        // PWM freq in kHz (1-250)
                        value = max(1, min(value, 250))
                        // Update PWM frequency
                        m.setPWMFreq(uint64(value) * shared.KHz)</span>

                case 10:<span class="cov0" title="0"></span>
                        // Back EMF motor control cutoff speed
                        // TODO: Implement this

                case 19:<span class="cov0" title="0">
                        // Consist address direction swap modifier
                        // Check for double-uno-reverse
                        m.ndotReverse = (value &gt;&gt; 7) != (m.cv[29] &amp; 1)</span>

                case 29:<span class="cov0" title="0">
                        // CV 29:
                        // Bits 7-5 are not relevant here
                        // Ignore bit 3, not concerned about RailCom here
                        // Ignore bit 2, not concerned about DC mode
                        if (value &amp; 0b00000010) == 0 </span><span class="cov0" title="0">{
                                m.speedMode = SpeedMode14
                        }</span> else<span class="cov0" title="0"> {
                                // Default to 28-speed mode, 128-speed mode is enabled automatically
                                // when a 128-speed packet is received
                                m.speedMode = SpeedMode28
                        }</span>
                        // ndotReverse uno-reverses the normal direction of travel
                        <span class="cov0" title="0">m.ndotReverse = (value &amp; 1) != (m.cv[19] &gt;&gt; 7)

                        // Update speed table in case bit 4 or bit 1 changed
                        // Bit 4: 0 = CV 2,5,6 speed curve, 1 = CV 67-94 speed table
                        m.userSpeedTable = (value &amp; 0b00010000) != 0
                        defer m.updateSpeedTable()
                        defer m.calculateAccelDecelRates()</span>

                case 53:<span class="cov0" title="0">
                        // Max speed EMF voltage
                        m.emfMax = float32(value) / 10</span>

                case 51, 52, 54, 55, 56:<span class="cov0" title="0">
                        // CV51 Kp gain cutover speed step
                        // CV52 Low speed Kp gain (proportional)
                        // CV54 High speed Kp gain (proportional)
                        // CV55 Ki gain (integral)
                        // CV56 Low speed PID scaling factor
                        defer m.updatePIDConfig()</span> // TODO: Is this the right idea? Not sure how to handle high/low speed switch

                case 65:<span class="cov0" title="0"></span>
                        // Startup kick to overcome static friction from a stop to speed step 1
                        // TODO: Implement this

                case 66, 95:<span class="cov0" title="0">
                        // Forward/reverse trim - n/128 * throttle vs. the opposite direction
                        // e.g. 64/128 reduces throttle by half, 192/128 increases throttle by 50%
                        defer m.updateDirectionTrims()</span>

                case 116, 117:<span class="cov0" title="0">
                        // Back EMF measurement interval in 100us steps (50-200) 5-20ms
                        value = max(50, min(value, 200))
                        defer m.updateBackEMFTiming()</span>

                case 118, 119:<span class="cov0" title="0">
                        // Back EMF measurement duration in 100us steps (10-40) 1-4ms
                        value = max(10, min(value, 40))
                        defer m.updateBackEMFTiming()</span>
                }

                // Special case for the 28-CV speed table
                <span class="cov0" title="0">if cvNumber &gt;= 67 &amp;&amp; cvNumber &lt;= 94 </span><span class="cov0" title="0">{
                        // Updates to the user speed table
                        defer m.updateSpeedTable()
                }</span>

                // Update the cached CV value
                <span class="cov0" title="0">m.cv[cvNumber] = value
                return true</span>
        }
}

func (m *Motor) RegisterCallbacks() <span class="cov0" title="0">{
        for i := uint16(2); i &lt;= 6; i++ </span><span class="cov0" title="0">{
                m.cvHandler.RegisterCallback(i, m.CVCallback())
        }</span>
        <span class="cov0" title="0">m.cvHandler.RegisterCallback(9, m.CVCallback())
        m.cvHandler.RegisterCallback(10, m.CVCallback())
        m.cvHandler.RegisterCallback(19, m.CVCallback())
        m.cvHandler.RegisterCallback(23, m.CVCallback())
        m.cvHandler.RegisterCallback(24, m.CVCallback())
        m.cvHandler.RegisterCallback(29, m.CVCallback())
        for i := uint16(51); i &lt;= 56; i++ </span><span class="cov0" title="0">{
                m.cvHandler.RegisterCallback(i, m.CVCallback())
        }</span>
        <span class="cov0" title="0">for i := uint16(65); i &lt;= 95; i++ </span><span class="cov0" title="0">{
                m.cvHandler.RegisterCallback(i, m.CVCallback())
        }</span>
        <span class="cov0" title="0">for i := uint16(116); i &lt;= 119; i++ </span><span class="cov0" title="0">{
                m.cvHandler.RegisterCallback(i, m.CVCallback())
        }</span>
}

// calculateAccelDecelRates updates the acceleration and deceleration rates
// based on CVs 3, 4, 23, and 24
func (m *Motor) calculateAccelDecelRates() <span class="cov0" title="0">{
        // Get base values from CV3 and CV4
        accelBase := float32(m.cv[3])
        decelBase := float32(m.cv[4])

        // Get adjustment values from CV23 and CV24
        accelAdj := float32(m.cv[23] &amp; 0x7F) // Lower 7 bits for magnitude
        decelAdj := float32(m.cv[24] &amp; 0x7F) // Lower 7 bits for magnitude

        // Apply sign based on bit 7
        if (m.cv[23] &amp; 0x80) != 0 </span><span class="cov0" title="0">{
                accelAdj = -accelAdj
        }</span>
        <span class="cov0" title="0">if (m.cv[24] &amp; 0x80) != 0 </span><span class="cov0" title="0">{
                decelAdj = -decelAdj
        }</span>

        // Calculate acceleration rate with formula:
        // (CV3 + adjustment from CV23) * 0.896 / number of speed steps
        <span class="cov0" title="0">m.accelRate = max(0, (accelBase+accelAdj)*0.896/float32(m.speedMode))

        // Calculate deceleration rate with formula:
        // (CV4 + adjustment from CV24) * 0.896 / number of speed steps
        m.decelRate = max(0, (decelBase+decelAdj)*0.896/float32(m.speedMode))</span>
}

// updatePIDConfig updates the PID controller based on CVs 51, 52, 54, 55, and 56
func (m *Motor) updatePIDConfig() <span class="cov0" title="0">{
        // Get the cutover speed step
        m.kpCutover = m.cv[51]

        // Get the low speed Kp gain
        m.kpLow = float32(m.cv[52]) / 10

        // Get the high speed Kp gain
        m.kpHigh = float32(m.cv[54]) / 10

        // Update the Kp gain based on the current speed
        if m.currentSpeed &lt; m.kpCutover </span><span class="cov0" title="0">{
                // Use the low speed Kp gain
                m.pid.Config.ProportionalGain = m.kpLow
        }</span> else<span class="cov0" title="0"> {
                // Use the high speed Kp gain
                m.pid.Config.ProportionalGain = m.kpHigh
        }</span>

        // Get the Ki gain
        <span class="cov0" title="0">m.pid.Config.IntegralGain = float32(m.cv[55]) / 10</span>
}

// TODO: Make sure to update the backemf interval when speed changes
// updateSpeedTable generates the speed table based on CV67-94 and other settings
func (m *Motor) updateSpeedTable() <span class="cov0" title="0">{
        if m.userSpeedTable </span><span class="cov0" title="0">{
                // Generate the speed table based on CV67-94
                m.generateUserSpeedTable() // TODO: Verify output
        }</span> else<span class="cov0" title="0"> {
                // Generate the speed table based on CV2, 5, and 6
                m.generate3PointSpeedTable()
        }</span>
}

// generate3PointSpeedTable creates a speed table using Vstart, Vmid, and Vmax
func (m *Motor) generate3PointSpeedTable() <span class="cov8" title="1">{
        // All speed values are in the range 0-1
        vStart := float32(m.cv[2]) / 255
        vMax := float32(m.cv[5]) / 255
        if vMax == 0 </span><span class="cov8" title="1">{
                vMax = 1.0
        }</span>
        <span class="cov8" title="1">vMid := float32(m.cv[6]) / 255
        if vMid == 0 </span><span class="cov8" title="1">{
                vMid = (vStart + vMax) / 2
        }</span>

        // Clear the table
        <span class="cov8" title="1">for i := range m.speedTable </span><span class="cov8" title="1">{
                m.speedTable[i] = 0
        }</span>

        // Get number of non-stationary speed steps and interpolate
        <span class="cov8" title="1">steps := int(m.speedMode)
        segmentSteps := int(m.speedMode / 2)
        // Per-step speed increase in the first segment
        lowStep := (vMid - vStart) / float32(segmentSteps)
        // Per-step speed increase in the second segment
        highStep := (vMax - vMid) / float32(segmentSteps-1)
        var value float32
        for i := range steps </span><span class="cov8" title="1">{
                if i &lt;= segmentSteps </span><span class="cov8" title="1">{
                        // First segment (between Vstart and Vmid)
                        value = vStart + float32(i)*lowStep
                }</span> else<span class="cov8" title="1"> if i == steps-1 </span><span class="cov8" title="1">{
                        // Last segment (Vmax)
                        value = vMax
                }</span> else<span class="cov8" title="1"> {
                        // Second segment (between Vmid and Vmax)
                        value = vMid + float32(i-segmentSteps)*highStep
                }</span>
                // Skip the first two speed steps (stop and emergency stop)
                <span class="cov8" title="1">m.speedTable[i+2] = value</span>
        }
}

// generateUserSpeedTable creates a speed table based on CV67-94, interpolating to 128 steps if necessary
func (m *Motor) generateUserSpeedTable() <span class="cov0" title="0">{
        // Clear the table
        for i := range m.speedTable </span><span class="cov0" title="0">{
                m.speedTable[i] = 0
        }</span>

        <span class="cov0" title="0">switch m.speedMode </span>{
        case SpeedMode14:<span class="cov0" title="0">
                // Skip every other CV value in 14-speed mode
                for i := range uint16(14) </span><span class="cov0" title="0">{
                        // Use every other CV value
                        m.speedTable[i+2] = float32(m.cv[2*i+67]) / 255
                }</span>
                <span class="cov0" title="0">m.speedTable[15] = float32(m.cv[94]) / 255</span>
        case SpeedMode28:<span class="cov0" title="0">
                // Use all CV values
                for i := range uint16(28) </span><span class="cov0" title="0">{
                        m.speedTable[i+2] = float32(m.cv[i+67]) / 255
                }</span>
        case SpeedMode128:<span class="cov0" title="0">
                // Interpolate to 128 steps
                for i := uint16(0); i &lt; uint16(m.speedMode); i++ </span><span class="cov0" title="0">{
                        // Calculate the index in the 28-speed table
                        index := i * uint16(SpeedMode28) / uint16(SpeedMode128)
                        // Interpolate between the two values
                        value := float32(m.cv[index+67]) + float32(m.cv[index+68]-m.cv[index+67])*float32(i)*28/128
                        m.speedTable[i+2] = value / 255
                }</span>
        default:<span class="cov0" title="0">
                panic("Invalid speed mode")</span>
        }
}

// updateDirectionTrims updates the forward and reverse trim values
func (m *Motor) updateDirectionTrims() <span class="cov0" title="0">{
        // Make sure we can't zero out the trims and prevent throttle from working at all
        fwd := m.cv[66]
        if fwd == 0 </span><span class="cov0" title="0">{
                fwd = 128
        }</span>
        <span class="cov0" title="0">rev := m.cv[95]
        if rev == 0 </span><span class="cov0" title="0">{
                rev = 128
        }</span>
        // Forward trim
        <span class="cov0" title="0">m.fwdTrim = float32(fwd) / 128
        // Reverse trim
        m.revTrim = float32(rev) / 128</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package motor

// SpeedMode defines the type of speed step mode
type SpeedMode uint8

const (
        // The value of each SpeedMode is the number of speed steps excluding stop and e-stop
        SpeedMode14  SpeedMode = 14
        SpeedMode28  SpeedMode = 28
        SpeedMode128 SpeedMode = 126
)

type Direction uint8

const (
        Reverse Direction = iota
        Forward
)

func (d Direction) String() string <span class="cov0" title="0">{
        switch d </span>{
        case Reverse:<span class="cov0" title="0">
                return "Reverse"</span>
        case Forward:<span class="cov0" title="0">
                return "Forward"</span>
        default:<span class="cov0" title="0">
                return "Unknown"</span>
        }
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package motor

import (
        "fmt"
        "sync"
        "time"

        "github.com/mikesmitty/rp24-dcc-decoder/internal/shared"
        "github.com/mikesmitty/rp24-dcc-decoder/pkg/cv"
        "github.com/mikesmitty/rp24-dcc-decoder/pkg/hal"
        "github.com/mikesmitty/rp24-dcc-decoder/pkg/iir"
        "github.com/mikesmitty/tinypid"
)

type Motor struct {
        cv        map[uint16]uint8
        cvHandler cv.Handler

        // H-bridge PWM outputs
        pwmA        *hal.SimplePWM
        pwmB        *hal.SimplePWM
        pwmDuty     float32
        pwmInterval time.Duration

        iirAlpha float32
        iir      *iir.IIRFilter
        iirRef   *iir.IIRFilter

        // Back-EMF measurement state for estimating speed
        adcRef      *hal.ADC
        emfADC      *hal.ADC
        emfA        shared.Pin
        emfB        shared.Pin
        emfDuration time.Duration
        emfInterval time.Duration
        emfMax      float32
        pwmMutex    sync.Mutex
        emfTarget   float32
        emfTicker   *time.Ticker
        emfTimer    *time.Timer
        emfValue    float32

        // Motor control state
        currentSpeed    uint8     // Current speed step/speed table index
        changeDirection bool      // Flag to indicate direction change commanded
        ndotReverse     bool      // Normal direction of travel is reversed
        reverse         bool      // Commanded direction of travel is reversed
        rawSpeed        float32   // currentSpeed without rounding for accel/decel rates
        speedAfterStop  uint8     // Next speed step after direction change
        speedMode       SpeedMode // Number of speed steps
        targetRaw       float32   // targetSpeed without rounding
        targetSpeed     uint8     // Commanded speed step

        accelRate float32 // Max steps per second accel
        decelRate float32 // Max steps per second decel
        fwdTrim   float32 // Forward speed trim
        revTrim   float32 // Reverse speed trim

        // Speed table for the max 128 speed steps (including stop and e-stop)
        speedTable     [128]float32
        userSpeedTable bool

        // For PID control
        DisablePID bool
        pid        tinypid.PIController
        kpCutover  uint8 // Speed step at which to switch from low to high PID gains
        kpLow      float32
        kpHigh     float32

        // For PID control
        lastControlTime time.Time
}

func NewMotor(conf cv.Handler, hw *hal.HAL, pinA, pinB, emfA, emfB, adcRef shared.Pin) *Motor <span class="cov0" title="0">{
        m := &amp;Motor{
                cv:              make(map[uint16]uint8),
                cvHandler:       conf,
                iirAlpha:        0.7,
                lastControlTime: time.Now(),
        }

        // Set up back EMF pins for ADC
        m.initBackEMF(emfA, emfB, adcRef)

        // Set up motor driver pins for PWM
        m.pwmInterval = 100 * time.Millisecond // TODO: Adjust this?
        err := m.initPWM(hw, pinA, pinB, uint64(m.cvHandler.CV(9))*shared.KHz, 0.0)
        if err != nil </span><span class="cov0" title="0">{
                panic(err.Error())</span>
        }

        <span class="cov0" title="0">m.RegisterCallbacks()

        return m</span>
}

func (m *Motor) Run() <span class="cov0" title="0">{
        for </span><span class="cov0" title="0">{
                time.Sleep(m.pwmInterval)
                m.runMotorControl()
        }</span>
}

// runMotorControl is the main control loop for the motor
func (m *Motor) runMotorControl() <span class="cov0" title="0">{
        now := time.Now()
        elapsed := now.Sub(m.lastControlTime)

        // Update speed step
        prevSpeed := m.currentSpeed
        m.updateSpeedStep(elapsed)
        if prevSpeed != m.currentSpeed </span><span class="cov0" title="0">{
                // If the speed step changed, update the PID controller config (update proportional gain for new speed step) and EMF target
                m.updatePIDConfig()
                m.emfTarget = m.speedTable[m.currentSpeed] * m.emfMax
        }</span>

        // Run the PID loop
        <span class="cov0" title="0">m.pid.Update(tinypid.PIControllerInput{
                ReferenceSignal: m.emfTarget,
                ActualSignal:    m.emfValue,
        })

        // Apply the PWM duty cycle
        if m.DisablePID </span><span class="cov0" title="0">{
                m.pwmDuty = m.speedTable[m.currentSpeed]
        }</span> else<span class="cov0" title="0"> {
                m.pwmDuty = m.pid.State.ControlSignal
        }</span>
        <span class="cov0" title="0">m.ApplyPWM(m.pwmDuty)

        // Update the last control time
        m.lastControlTime = now</span>
}

// SpeedMode returns the current DCC speed mode (14, 28, or 128 steps)
func (m *Motor) SpeedMode() SpeedMode <span class="cov0" title="0">{
        return m.speedMode
}</span>

// SetSpeedMode sets the DCC speed mode (14, 28, or 128 steps)
func (m *Motor) SetSpeedMode(mode SpeedMode) <span class="cov0" title="0">{
        if m.speedMode == mode </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">m.speedMode = mode
        m.calculateAccelDecelRates()
        m.updateSpeedTable()
        m.updateBackEMFTiming()</span>
}

func (m *Motor) SetSpeed(speed uint8, reverse bool) <span class="cov0" title="0">{
        // Update direction
        m.changeDirection = m.reverse != reverse

        // Handle emergency stop (speed value 1)
        if speed == 1 </span><span class="cov0" title="0">{
                m.emergencyStop()
                return
        }</span>

        <span class="cov0" title="0">if m.targetSpeed == speed &amp;&amp; !m.changeDirection </span><span class="cov0" title="0">{
                return
        }</span>

        // If we're changing direction and currently moving, slow down and stop first
        <span class="cov0" title="0">if !m.changeDirection </span><span class="cov0" title="0">{
                m.setTargetSpeed(speed)
                m.updateBackEMFTiming()
        }</span> else<span class="cov0" title="0"> if m.currentSpeed &gt; 0 &amp;&amp; m.targetSpeed &gt; 0 </span><span class="cov0" title="0">{
                m.setTargetSpeed(0)
                m.speedAfterStop = speed
        }</span>
}

// stopMotor stops the motor
func (m *Motor) stopMotor() <span class="cov0" title="0">{
        m.ApplyPWM(0.0)
}</span>

// emergencyStop immediately stops the motor
func (m *Motor) emergencyStop() <span class="cov0" title="0">{
        // For emergency stop, we want to stop immediately
        m.stopMotor()
        m.currentSpeed = 0
        m.rawSpeed = 0.0
        m.setTargetSpeed(0)
        m.pid.Reset()
        m.updatePIDConfig()
}</span>

// updateSpeedStep adjusts the current speed step up or down based on max accel/decel rates
func (m *Motor) updateSpeedStep(elapsed time.Duration) <span class="cov0" title="0">{
        // If we're stopped and set to change direction, set the new speed
        if m.changeDirection &amp;&amp; m.targetSpeed == 0 &amp;&amp; m.currentSpeed == 0 </span><span class="cov0" title="0">{
                m.reverse = !m.reverse
                m.setTargetSpeed(m.speedAfterStop)
                m.speedAfterStop = 0
                m.changeDirection = false
                m.pid.Reset()
                m.setupADC(m.Direction())
        }</span>

        // TODO: Handle going from 0 to non-zero speed after startup from dirty rail
        <span class="cov0" title="0">if m.currentSpeed &gt; m.targetSpeed &amp;&amp; m.rawSpeed-m.targetRaw &gt; 0.5 </span><span class="cov0" title="0">{
                fmt.Printf("slow down - current: %d target: %d duty: %0.2f\n", m.currentSpeed, m.targetSpeed, m.speedTable[m.targetSpeed]) // TODO: Cleanup
                if m.decelRate &gt; 0 </span><span class="cov0" title="0">{
                        // decelRate: seconds per step * elapsed seconds = steps decreased
                        m.rawSpeed -= m.decelRate * float32(elapsed.Seconds())
                }</span> else<span class="cov0" title="0"> {
                        // If acceleration rate is zero, change to targetSpeed immediately
                        m.rawSpeed = m.targetRaw
                }</span>
        } else<span class="cov0" title="0"> if m.currentSpeed &lt; m.targetSpeed &amp;&amp; m.targetRaw-m.rawSpeed &gt; 0.5 </span><span class="cov0" title="0">{
                fmt.Printf("speed up - current: %d target: %d duty: %0.2f\n", m.currentSpeed, m.targetSpeed, m.speedTable[m.targetSpeed]) // TODO: Cleanup
                if m.accelRate &gt; 0 </span><span class="cov0" title="0">{
                        // accelRate: seconds per step * elapsed seconds = steps increased
                        m.rawSpeed += m.accelRate * float32(elapsed.Seconds())
                }</span> else<span class="cov0" title="0"> {
                        // If acceleration rate is zero, change to targetSpeed immediately
                        m.rawSpeed = m.targetRaw
                }</span>
        }
        // Round rawSpeed to nearest integer for speed table index
        <span class="cov0" title="0">m.currentSpeed = uint8(m.rawSpeed + 0.5)</span>
}

// Make sure we always set the target speed and raw speed together
func (m *Motor) setTargetSpeed(speed uint8) <span class="cov0" title="0">{
        m.targetSpeed = speed
        m.targetRaw = float32(speed)
}</span>

func (m *Motor) Direction() Direction <span class="cov0" title="0">{
        if m.reverse == m.ndotReverse </span><span class="cov0" title="0">{
                return Forward
        }</span>
        <span class="cov0" title="0">return Reverse</span>
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package motor

import (
        "math/rand/v2"

        "github.com/mikesmitty/rp24-dcc-decoder/internal/shared"
        "github.com/mikesmitty/rp24-dcc-decoder/pkg/hal"
)

func (m *Motor) initPWM(hw *hal.HAL, pinA, pinB shared.Pin, freq uint64, duty float32) error <span class="cov0" title="0">{
        if freq == 0 </span><span class="cov0" title="0">{
                freq = 40 * shared.KHz
                println("got pwm freq 0, using default motor PWM frequency of 40kHz")
        }</span>

        <span class="cov0" title="0">pwmA, err := hw.InitPWM(pinA, freq, 0.0)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">pwmB, err := hw.InitPWM(pinB, freq, 0.0)
        if err != nil </span><span class="cov0" title="0">{
                panic(err.Error())</span>
        }
        <span class="cov0" title="0">m.pwmA = pwmA
        m.pwmB = pwmB

        return nil</span>
}

// ApplyPWM sets the PWM outputs according to direction and duty cycle
func (m *Motor) ApplyPWM(dutyCycle float32) <span class="cov0" title="0">{
        // Lock the pwm mutex to prevent turning on the motor while measuring back EMF
        m.pwmMutex.Lock()
        defer m.pwmMutex.Unlock()

        // Take into account both m.reverse and m.ndotReverse to select a direction
        if m.Direction() == Reverse </span><span class="cov0" title="0">{
                m.pwmA.SetDuty(0.0)
                m.pwmB.SetDuty(dutyCycle * m.revTrim)
        }</span> else<span class="cov0" title="0"> {
                m.pwmA.SetDuty(dutyCycle * m.fwdTrim)
                m.pwmB.SetDuty(0.0)
        }</span>
}

// TODO: Use this function
// Dither the motor PWM frequency to improve low-speed startup. Window size represents the
// maximum amount of dithering to apply in 100Hz steps
func (m *Motor) dither(freq, windowSize uint64) <span class="cov0" title="0">{
        modifier := rand.Uint64N(windowSize)
        neg := modifier &amp; 1
        if neg == 1 </span><span class="cov0" title="0">{
                modifier = -modifier
        }</span>
        <span class="cov0" title="0">modifier *= 100
        m.setPWMFreq(freq + modifier)</span>
}

// setPWMFreq sets the PWM frequency for the motor driver signal
func (m *Motor) setPWMFreq(freq uint64) <span class="cov0" title="0">{
        m.pwmA.SetFreq(freq)
        m.pwmB.SetFreq(freq)
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">//go:build !rp

package ringbuffer

import (
        "golang.org/x/exp/constraints"
)

const (
        bufferSize = 64
)

type Number interface {
        constraints.Integer | constraints.Float | constraints.Complex
}

type RingBuffer[T Number] struct {
        buffer [bufferSize]T
        head   uint16
        tail   uint16
}

// NewRingBuffer returns a new ring buffer.
func NewRingBuffer[T Number]() *RingBuffer[T] <span class="cov0" title="0">{
        return &amp;RingBuffer[T]{}
}</span>

// Used returns how many bytes in buffer have been used.
func (rb *RingBuffer[T]) Used() uint16 <span class="cov0" title="0">{
        return uint16(rb.head - rb.tail)
}</span>

// Full returns true if the buffer is full.
func (rb *RingBuffer[T]) Full() bool <span class="cov0" title="0">{
        return rb.Used() == bufferSize
}</span>

// Put stores a value in the buffer. If the buffer is already
// full, the method will return false.
func (rb *RingBuffer[T]) Put(val T) bool <span class="cov0" title="0">{
        if !rb.Full() </span><span class="cov0" title="0">{
                rb.head++
                rb.buffer[rb.head%bufferSize] = val
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

// Get returns a byte from the buffer. If the buffer is empty,
// the method will return a false as the second value.
func (rb *RingBuffer[T]) Get() (T, bool) <span class="cov0" title="0">{
        if rb.Used() != 0 </span><span class="cov0" title="0">{
                rb.tail++
                return rb.buffer[rb.tail%bufferSize], true
        }</span>
        <span class="cov0" title="0">return *new(T), false</span>
}

// Clear resets the head and tail pointer to zero.
func (rb *RingBuffer[T]) Clear() <span class="cov0" title="0">{
        rb.head = 0
        rb.tail = 0
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">//go:build !rp

package store

func (c *Store) initFlash() error <span class="cov8" title="1">{
        return nil
}</span>

func (c *Store) persist(index, cvNumber uint16, value uint8) bool <span class="cov8" title="1">{
        return true
}</span>

func (c *Store) ReadCVFromFlash(index, cvNumber uint16) (uint8, bool) <span class="cov0" title="0">{
        return 0, true
}</span>

func (c *Store) ProcessChanges() bool <span class="cov8" title="1">{
        // Clear the dirty flags
        for cvNumber, data := range c.data </span><span class="cov8" title="1">{
                if (data.Flags &amp; Dirty) != 0 </span><span class="cov8" title="1">{
                        data.Flags &amp;^= Dirty    // Use bitwise AND NOT to clear the flag
                        c.data[cvNumber] = data // Store back into the map
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

// Bool return value indicates if the index file was found
func (s *Store) LoadIndex(newIndex uint16) (bool, error) <span class="cov0" title="0">{
        if newIndex &gt; 0 </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package store

import (
        "runtime"
        "time"

        "tinygo.org/x/tinyfs"
)

// CVFlags uses a bitmap for efficient storage and checking
type CVFlags uint8

const (
        Volatile   CVFlags = 0         // No flags
        Dirty      CVFlags = 1 &lt;&lt; iota // CV has been written to
        ReadOnly                       // CV is read-only
        Persistent                     // CV should be saved to non-volatile memory
)

// Data holds the value, default, and flags for a single CV
type Data struct {
        Value   uint8
        Default uint8
        Flags   CVFlags
}

type Store struct {
        // Store is our map of CV number to CVData
        async bool
        // uint16 because 64kV ought to be enough for anybody
        data      map[uint16]Data
        fs        tinyfs.Filesystem
        index     uint16
        indexFile string
        ticker    *time.Ticker
}

// NewStore sets up the CV store and mounts the filesystem
func NewStore() *Store <span class="cov8" title="1">{
        c := &amp;Store{
                data: make(map[uint16]Data, 256),
        }

        err := c.initFlash()
        if err != nil </span><span class="cov0" title="0">{
                println("could not initialize flash: " + err.Error())
        }</span>

        <span class="cov8" title="1">return c</span>
}

// Run periodically processes CV changes and persists them to flash
func (s *Store) Run() <span class="cov0" title="0">{
        s.ticker = time.NewTicker(500 * time.Millisecond)
        s.async = true
        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-s.ticker.C:<span class="cov0" title="0">
                        s.ProcessChanges()</span>
                default:<span class="cov0" title="0">
                        runtime.Gosched()</span>
                }
        }
}

// SetDefault sets the value, default value and flags for a CV
func (s *Store) SetDefault(cvNumber uint16, defaultValue uint8, flags CVFlags) <span class="cov8" title="1">{
        s.data[cvNumber] = Data{
                Value:   defaultValue,
                Default: defaultValue,
                Flags:   flags,
        }
}</span>

// SetReadOnly sets a CV to read-only
func (s *Store) SetReadOnly(cvNumber uint16) <span class="cov8" title="1">{
        data, ok := s.data[cvNumber]
        if !ok </span><span class="cov0" title="0">{
                return // CV not found or unused
        }</span>
        <span class="cov8" title="1">data.Flags |= ReadOnly
        s.data[cvNumber] = data</span>
}

// CV retrieves the value of a CV
func (s *Store) CV(cvNumber uint16) (uint8, bool) <span class="cov8" title="1">{
        data, ok := s.data[cvNumber]
        if !ok </span><span class="cov0" title="0">{
                return 0, false // CV not found or unused
        }</span>
        <span class="cov8" title="1">return data.Value, true</span>
}

// IndexedCV retrieves the value of a CV using the provided index
// Does not check whether or not the CV is valid, only if the read succeeded
func (s *Store) IndexedCV(index, cvNumber uint16) (uint8, bool) <span class="cov0" title="0">{
        if index == s.index </span><span class="cov0" title="0">{
                return s.CV(cvNumber)
        }</span>
        <span class="cov0" title="0">return s.ReadCVFromFlash(index, cvNumber)</span>
}

// Set sets the value of a CV, marking it as dirty if it's not read-only
func (s *Store) Set(cvNumber uint16, value uint8) bool <span class="cov8" title="1">{
        data, ok := s.data[cvNumber]
        if (data.Flags &amp; ReadOnly) != 0 </span><span class="cov8" title="1">{
                return false // CV is read-only
        }</span>
        <span class="cov8" title="1">if !ok || data.Value != value </span><span class="cov8" title="1">{ // Only update if the value is different or key is missing
                data.Value = value
                data.Flags |= Dirty     // Mark as dirty
                s.data[cvNumber] = data // Store back into the map
        }</span>

        // If we're not running async, persist the change immediately
        <span class="cov8" title="1">if !s.async &amp;&amp; (data.Flags&amp;Dirty) != 0 &amp;&amp; (data.Flags&amp;Persistent) != 0 </span><span class="cov0" title="0">{
                return s.persist(s.index, cvNumber, value)
        }</span>
        <span class="cov8" title="1">return true</span>
}

// Reset resets a single CV to its default value
func (s *Store) Reset(cvNumber uint16) bool <span class="cov8" title="1">{
        data, ok := s.data[cvNumber]
        if !ok </span><span class="cov0" title="0">{
                return false // CV not found or unused
        }</span>
        <span class="cov8" title="1">if data.Value != data.Default </span><span class="cov8" title="1">{ // Only update and mark dirty if needed
                data.Value = data.Default
                data.Flags |= Dirty
                s.data[cvNumber] = data
                // If we're not running async, persist the change immediately
                if !s.async </span><span class="cov8" title="1">{
                        return s.persist(s.index, cvNumber, data.Value)
                }</span>
        }
        <span class="cov0" title="0">return true</span>
}

// ResetAllCVs resets all used CVs to their default values
func (s *Store) ResetAll() <span class="cov8" title="1">{
        for cvNumber := range s.data </span><span class="cov8" title="1">{
                s.Reset(cvNumber)
        }</span>
}

// Clear empties the CV store in preparation for loading a new index
func (s *Store) Clear() <span class="cov0" title="0">{
        clear(s.data)
}</span>

// Persist sets a CV value and immediately writes it to onboard flash
func (s *Store) Persist(cvNumber uint16, value uint8) bool <span class="cov0" title="0">{
        // Since this is for the current index, also set the current value
        s.Set(cvNumber, value)
        return s.persist(s.index, cvNumber, value)
}</span>

// IndexedPersist writes a CV value to onboard flash using the provided index
func (s *Store) IndexedPersist(index, cvNumber uint16, value uint8) bool <span class="cov0" title="0">{
        return s.persist(index, cvNumber, value)
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
